{
    "noxfile.py": {
        "functions": {
            "test_pydantic_v1": {
                "signature": "(session: nox.Session) -> None"
            }
        }
    },
    "examples\\messages_stream.py": {
        "functions": {
            "main": {
                "signature": "async () -> None"
            }
        }
    },
    "examples\\text_completions_demo_async.py": {
        "functions": {
            "main": {
                "signature": "async () -> None"
            }
        }
    },
    "examples\\text_completions_demo_sync.py": {
        "functions": {
            "main": {
                "signature": "() -> None"
            }
        }
    },
    "examples\\text_completions_streaming.py": {
        "functions": {
            "sync_stream": {
                "signature": "() -> None"
            },
            "async_stream": {
                "signature": "async () -> None"
            },
            "stream_error": {
                "signature": "() -> None"
            }
        }
    },
    "examples\\tools_stream.py": {
        "functions": {
            "main": {
                "signature": "async () -> None"
            }
        }
    },
    "examples\\vertex.py": {
        "functions": {
            "sync_client": {
                "signature": "() -> None"
            },
            "async_client": {
                "signature": "async () -> None"
            }
        }
    },
    "scripts\\utils\\ruffen-docs.py": {
        "functions": {
            "format_str": {
                "signature": "(src: str) -> tuple[str, Sequence[CodeBlockError]]"
            },
            "format_code_block": {
                "signature": "(code: str) -> str"
            },
            "format_file": {
                "signature": "(filename: str, skip_errors: bool) -> int"
            },
            "main": {
                "signature": "(argv=None: Sequence[str] | None) -> int"
            }
        },
        "classes": {}
    },
    "src\\anthropic\\pagination.py": {
        "classes": {
            "SyncPage": {
                "methods": {
                    "_get_page_items": {
                        "signature": "(self) -> List[_T]"
                    },
                    "next_page_info": {
                        "signature": "(self) -> Optional[PageInfo]"
                    }
                }
            },
            "AsyncPage": {
                "methods": {
                    "_get_page_items": {
                        "signature": "(self) -> List[_T]"
                    },
                    "next_page_info": {
                        "signature": "(self) -> Optional[PageInfo]"
                    }
                }
            }
        }
    },
    "src\\anthropic\\_base_client.py": {
        "functions": {
            "make_request_options": {
                "signature": "() -> RequestOptions",
                "docstring": "Create a dict of type RequestOptions without keys of NotGiven values."
            },
            "get_platform": {
                "signature": "() -> Platform"
            },
            "platform_headers": {
                "signature": "(version: str) -> Dict[str, str]"
            },
            "get_python_runtime": {
                "signature": "() -> str"
            },
            "get_python_version": {
                "signature": "() -> str"
            },
            "get_architecture": {
                "signature": "() -> Arch"
            },
            "_merge_mappings": {
                "signature": "(obj1: Mapping[_T_co, Union[_T, Omit]], obj2: Mapping[_T_co, Union[_T, Omit]]) -> Dict[_T_co, _T]",
                "docstring": "Merge two mappings of the same type, removing any values that are instances of `Omit`.\n\nIn cases with duplicate keys the second mapping takes precedence."
            }
        },
        "classes": {
            "PageInfo": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "__repr__": {
                        "signature": "(self) -> str"
                    }
                },
                "docstring": "Stores the necessary information to build the request to retrieve the next page.\n\nEither `url` or `params` must be set."
            },
            "BasePage": {
                "methods": {
                    "has_next_page": {
                        "signature": "(self) -> bool"
                    },
                    "next_page_info": {
                        "signature": "(self) -> Optional[PageInfo]"
                    },
                    "_get_page_items": {
                        "signature": "(self) -> Iterable[_T]"
                    },
                    "_params_from_url": {
                        "signature": "(self, url: URL) -> httpx.QueryParams"
                    },
                    "_info_to_options": {
                        "signature": "(self, info: PageInfo) -> FinalRequestOptions"
                    }
                },
                "docstring": "Defines the core interface for pagination.\n\nType Args:\n    ModelT: The pydantic model that represents an item in the response.\n\nMethods:\n    has_next_page(): Check if there is another page available\n    next_page_info(): Get the necessary information to make a request for the next page"
            },
            "BaseSyncPage": {
                "methods": {
                    "_set_private_attributes": {
                        "signature": "(self, client: SyncAPIClient, model: Type[_T], options: FinalRequestOptions) -> None"
                    },
                    "__iter__": {
                        "signature": "(self) -> Iterator[_T]"
                    },
                    "iter_pages": {
                        "signature": "(self: SyncPageT) -> Iterator[SyncPageT]"
                    },
                    "get_next_page": {
                        "signature": "(self: SyncPageT) -> SyncPageT"
                    }
                }
            },
            "AsyncPaginator": {
                "methods": {
                    "__init__": {
                        "signature": "(self, client: AsyncAPIClient, options: FinalRequestOptions, page_cls: Type[AsyncPageT], model: Type[_T]) -> None"
                    },
                    "__await__": {
                        "signature": "(self) -> Generator[Any, None, AsyncPageT]"
                    },
                    "_get_page": {
                        "signature": "async (self) -> AsyncPageT"
                    },
                    "__aiter__": {
                        "signature": "async (self) -> AsyncIterator[_T]"
                    }
                }
            },
            "BaseAsyncPage": {
                "methods": {
                    "_set_private_attributes": {
                        "signature": "(self, model: Type[_T], client: AsyncAPIClient, options: FinalRequestOptions) -> None"
                    },
                    "__aiter__": {
                        "signature": "async (self) -> AsyncIterator[_T]"
                    },
                    "iter_pages": {
                        "signature": "async (self: AsyncPageT) -> AsyncIterator[AsyncPageT]"
                    },
                    "get_next_page": {
                        "signature": "async (self: AsyncPageT) -> AsyncPageT"
                    }
                }
            },
            "BaseClient": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "_enforce_trailing_slash": {
                        "signature": "(self, url: URL) -> URL"
                    },
                    "_make_status_error_from_response": {
                        "signature": "(self, response: httpx.Response) -> APIStatusError"
                    },
                    "_make_status_error": {
                        "signature": "(self, err_msg: str) -> _exceptions.APIStatusError"
                    },
                    "_build_headers": {
                        "signature": "(self, options: FinalRequestOptions) -> httpx.Headers"
                    },
                    "_prepare_url": {
                        "signature": "(self, url: str) -> URL",
                        "docstring": "Merge a URL argument together with any 'base_url' on the client,\nto create the URL used for the outgoing request."
                    },
                    "_make_sse_decoder": {
                        "signature": "(self) -> SSEDecoder | SSEBytesDecoder"
                    },
                    "_build_request": {
                        "signature": "(self, options: FinalRequestOptions) -> httpx.Request"
                    },
                    "_serialize_multipartform": {
                        "signature": "(self, data: Mapping[object, object]) -> dict[str, object]"
                    },
                    "_maybe_override_cast_to": {
                        "signature": "(self, cast_to: type[ResponseT], options: FinalRequestOptions) -> type[ResponseT]"
                    },
                    "_should_stream_response_body": {
                        "signature": "(self, request: httpx.Request) -> bool"
                    },
                    "_process_response_data": {
                        "signature": "(self) -> ResponseT"
                    },
                    "qs": {
                        "signature": "(self) -> Querystring"
                    },
                    "custom_auth": {
                        "signature": "(self) -> httpx.Auth | None"
                    },
                    "auth_headers": {
                        "signature": "(self) -> dict[str, str]"
                    },
                    "default_headers": {
                        "signature": "(self) -> dict[str, str | Omit]"
                    },
                    "default_query": {
                        "signature": "(self) -> dict[str, object]"
                    },
                    "_validate_headers": {
                        "signature": "(self, headers: Headers, custom_headers: Headers) -> None",
                        "docstring": "Validate the given default headers and custom headers.\n\nDoes nothing by default."
                    },
                    "user_agent": {
                        "signature": "(self) -> str"
                    },
                    "base_url": {
                        "signature": "(self, url: URL | str) -> None"
                    },
                    "platform_headers": {
                        "signature": "(self) -> Dict[str, str]"
                    },
                    "_parse_retry_after_header": {
                        "signature": "(self, response_headers=None: Optional[httpx.Headers]) -> float | None",
                        "docstring": "Returns a float of the number of seconds (not milliseconds) to wait after retrying, or None if unspecified.\n\nAbout the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\nSee also  https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After#syntax"
                    },
                    "_calculate_retry_timeout": {
                        "signature": "(self, remaining_retries: int, options: FinalRequestOptions, response_headers=None: Optional[httpx.Headers]) -> float"
                    },
                    "_should_retry": {
                        "signature": "(self, response: httpx.Response) -> bool"
                    },
                    "_idempotency_key": {
                        "signature": "(self) -> str"
                    }
                }
            },
            "_DefaultHttpxClient": {
                "methods": {
                    "__init__": {
                        "signature": "(self, **kwargs: Any) -> None"
                    }
                }
            },
            "SyncHttpxClientWrapper": {
                "methods": {
                    "__del__": {
                        "signature": "(self) -> None"
                    }
                }
            },
            "SyncAPIClient": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "is_closed": {
                        "signature": "(self) -> bool"
                    },
                    "close": {
                        "signature": "(self) -> None",
                        "docstring": "Close the underlying HTTPX client.\n\nThe client will *not* be usable after this."
                    },
                    "__enter__": {
                        "signature": "(self: _T) -> _T"
                    },
                    "__exit__": {
                        "signature": "(self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None"
                    },
                    "_prepare_options": {
                        "signature": "(self, options: FinalRequestOptions) -> FinalRequestOptions",
                        "docstring": "Hook for mutating the given options"
                    },
                    "_prepare_request": {
                        "signature": "(self, request: httpx.Request) -> None",
                        "docstring": "This method is used as a callback for mutating the `Request` object\nafter it has been constructed.\nThis is useful for cases where you want to add certain headers based off of\nthe request properties, e.g. `url`, `method` etc."
                    },
                    "request": {
                        "signature": "(self, cast_to: Type[ResponseT], options: FinalRequestOptions, remaining_retries=None: Optional[int]) -> ResponseT | _StreamT"
                    },
                    "_request": {
                        "signature": "(self) -> ResponseT | _StreamT"
                    },
                    "_retry_request": {
                        "signature": "(self, options: FinalRequestOptions, cast_to: Type[ResponseT]) -> ResponseT | _StreamT"
                    },
                    "_process_response": {
                        "signature": "(self) -> ResponseT"
                    },
                    "_request_api_list": {
                        "signature": "(self, model: Type[object], page: Type[SyncPageT], options: FinalRequestOptions) -> SyncPageT"
                    },
                    "get": {
                        "signature": "(self, path: str) -> ResponseT | _StreamT"
                    },
                    "post": {
                        "signature": "(self, path: str) -> ResponseT | _StreamT"
                    },
                    "patch": {
                        "signature": "(self, path: str) -> ResponseT"
                    },
                    "put": {
                        "signature": "(self, path: str) -> ResponseT"
                    },
                    "delete": {
                        "signature": "(self, path: str) -> ResponseT"
                    },
                    "get_api_list": {
                        "signature": "(self, path: str) -> SyncPageT"
                    }
                }
            },
            "_DefaultAsyncHttpxClient": {
                "methods": {
                    "__init__": {
                        "signature": "(self, **kwargs: Any) -> None"
                    }
                }
            },
            "AsyncHttpxClientWrapper": {
                "methods": {
                    "__del__": {
                        "signature": "(self) -> None"
                    }
                }
            },
            "AsyncAPIClient": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "is_closed": {
                        "signature": "(self) -> bool"
                    },
                    "close": {
                        "signature": "async (self) -> None",
                        "docstring": "Close the underlying HTTPX client.\n\nThe client will *not* be usable after this."
                    },
                    "__aenter__": {
                        "signature": "async (self: _T) -> _T"
                    },
                    "__aexit__": {
                        "signature": "async (self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None"
                    },
                    "_prepare_options": {
                        "signature": "async (self, options: FinalRequestOptions) -> FinalRequestOptions",
                        "docstring": "Hook for mutating the given options"
                    },
                    "_prepare_request": {
                        "signature": "async (self, request: httpx.Request) -> None",
                        "docstring": "This method is used as a callback for mutating the `Request` object\nafter it has been constructed.\nThis is useful for cases where you want to add certain headers based off of\nthe request properties, e.g. `url`, `method` etc."
                    },
                    "request": {
                        "signature": "async (self, cast_to: Type[ResponseT], options: FinalRequestOptions) -> ResponseT | _AsyncStreamT"
                    },
                    "_request": {
                        "signature": "async (self, cast_to: Type[ResponseT], options: FinalRequestOptions) -> ResponseT | _AsyncStreamT"
                    },
                    "_retry_request": {
                        "signature": "async (self, options: FinalRequestOptions, cast_to: Type[ResponseT]) -> ResponseT | _AsyncStreamT"
                    },
                    "_process_response": {
                        "signature": "async (self) -> ResponseT"
                    },
                    "_request_api_list": {
                        "signature": "(self, model: Type[_T], page: Type[AsyncPageT], options: FinalRequestOptions) -> AsyncPaginator[_T, AsyncPageT]"
                    },
                    "get": {
                        "signature": "async (self, path: str) -> ResponseT | _AsyncStreamT"
                    },
                    "post": {
                        "signature": "async (self, path: str) -> ResponseT | _AsyncStreamT"
                    },
                    "patch": {
                        "signature": "async (self, path: str) -> ResponseT"
                    },
                    "put": {
                        "signature": "async (self, path: str) -> ResponseT"
                    },
                    "delete": {
                        "signature": "async (self, path: str) -> ResponseT"
                    },
                    "get_api_list": {
                        "signature": "(self, path: str) -> AsyncPaginator[_T, AsyncPageT]"
                    }
                }
            },
            "ForceMultipartDict": {
                "methods": {
                    "__bool__": {
                        "signature": "(self) -> bool"
                    }
                }
            },
            "OtherPlatform": {
                "methods": {
                    "__init__": {
                        "signature": "(self, name: str) -> None"
                    },
                    "__str__": {
                        "signature": "(self) -> str"
                    }
                }
            },
            "OtherArch": {
                "methods": {
                    "__init__": {
                        "signature": "(self, name: str) -> None"
                    },
                    "__str__": {
                        "signature": "(self) -> str"
                    }
                }
            }
        }
    },
    "src\\anthropic\\_client.py": {
        "classes": {
            "Anthropic": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None",
                        "docstring": "Construct a new synchronous anthropic client instance.\n\nThis automatically infers the following arguments from their corresponding environment variables if they are not provided:\n- `api_key` from `ANTHROPIC_API_KEY`\n- `auth_token` from `ANTHROPIC_AUTH_TOKEN`"
                    },
                    "qs": {
                        "signature": "(self) -> Querystring"
                    },
                    "auth_headers": {
                        "signature": "(self) -> dict[str, str]"
                    },
                    "_api_key_auth": {
                        "signature": "(self) -> dict[str, str]"
                    },
                    "_bearer_auth": {
                        "signature": "(self) -> dict[str, str]"
                    },
                    "default_headers": {
                        "signature": "(self) -> dict[str, str | Omit]"
                    },
                    "_validate_headers": {
                        "signature": "(self, headers: Headers, custom_headers: Headers) -> None"
                    },
                    "copy": {
                        "signature": "(self) -> Self",
                        "docstring": "Create a new client instance re-using the same options given to the current client with optional overriding."
                    },
                    "count_tokens": {
                        "signature": "(self, text: str) -> int",
                        "docstring": "Count the number of tokens in a given string.\n\nNote that this is only accurate for older models, e.g. `claude-2.1`. For newer\nmodels this can only be used as a _very_ rough estimate, instead you should rely\non the `usage` property in the response for exact counts."
                    },
                    "get_tokenizer": {
                        "signature": "(self) -> TokenizerType"
                    },
                    "_make_status_error": {
                        "signature": "(self, err_msg: str) -> APIStatusError"
                    }
                }
            },
            "AsyncAnthropic": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None",
                        "docstring": "Construct a new async anthropic client instance.\n\nThis automatically infers the following arguments from their corresponding environment variables if they are not provided:\n- `api_key` from `ANTHROPIC_API_KEY`\n- `auth_token` from `ANTHROPIC_AUTH_TOKEN`"
                    },
                    "qs": {
                        "signature": "(self) -> Querystring"
                    },
                    "auth_headers": {
                        "signature": "(self) -> dict[str, str]"
                    },
                    "_api_key_auth": {
                        "signature": "(self) -> dict[str, str]"
                    },
                    "_bearer_auth": {
                        "signature": "(self) -> dict[str, str]"
                    },
                    "default_headers": {
                        "signature": "(self) -> dict[str, str | Omit]"
                    },
                    "_validate_headers": {
                        "signature": "(self, headers: Headers, custom_headers: Headers) -> None"
                    },
                    "copy": {
                        "signature": "(self) -> Self",
                        "docstring": "Create a new client instance re-using the same options given to the current client with optional overriding."
                    },
                    "count_tokens": {
                        "signature": "async (self, text: str) -> int",
                        "docstring": "Count the number of tokens in a given string.\n\nNote that this is only accurate for older models, e.g. `claude-2.1`. For newer\nmodels this can only be used as a _very_ rough estimate, instead you should rely\non the `usage` property in the response for exact counts."
                    },
                    "get_tokenizer": {
                        "signature": "async (self) -> TokenizerType"
                    },
                    "_make_status_error": {
                        "signature": "(self, err_msg: str) -> APIStatusError"
                    }
                }
            },
            "AnthropicWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, client: Anthropic) -> None"
                    }
                }
            },
            "AsyncAnthropicWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, client: AsyncAnthropic) -> None"
                    }
                }
            },
            "AnthropicWithStreamedResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, client: Anthropic) -> None"
                    }
                }
            },
            "AsyncAnthropicWithStreamedResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, client: AsyncAnthropic) -> None"
                    }
                }
            }
        }
    },
    "src\\anthropic\\_compat.py": {
        "functions": {
            "parse_obj": {
                "signature": "(model: type[_ModelT], value: object) -> _ModelT"
            },
            "field_is_required": {
                "signature": "(field: FieldInfo) -> bool"
            },
            "field_get_default": {
                "signature": "(field: FieldInfo) -> Any"
            },
            "field_outer_type": {
                "signature": "(field: FieldInfo) -> Any"
            },
            "get_model_config": {
                "signature": "(model: type[pydantic.BaseModel]) -> Any"
            },
            "get_model_fields": {
                "signature": "(model: type[pydantic.BaseModel]) -> dict[str, FieldInfo]"
            },
            "model_copy": {
                "signature": "(model: _ModelT) -> _ModelT"
            },
            "model_json": {
                "signature": "(model: pydantic.BaseModel) -> str"
            },
            "model_dump": {
                "signature": "(model: pydantic.BaseModel) -> dict[str, Any]"
            },
            "model_parse": {
                "signature": "(model: type[_ModelT], data: Any) -> _ModelT"
            }
        }
    },
    "src\\anthropic\\_exceptions.py": {
        "classes": {
            "APIError": {
                "methods": {
                    "__init__": {
                        "signature": "(self, message: str, request: httpx.Request) -> None"
                    }
                }
            },
            "APIResponseValidationError": {
                "methods": {
                    "__init__": {
                        "signature": "(self, response: httpx.Response, body: object | None) -> None"
                    }
                }
            },
            "APIStatusError": {
                "methods": {
                    "__init__": {
                        "signature": "(self, message: str) -> None"
                    }
                },
                "docstring": "Raised when an API response has a status code of 4xx or 5xx."
            },
            "APIConnectionError": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    }
                }
            },
            "APITimeoutError": {
                "methods": {
                    "__init__": {
                        "signature": "(self, request: httpx.Request) -> None"
                    }
                }
            }
        }
    },
    "src\\anthropic\\_files.py": {
        "functions": {
            "is_base64_file_input": {
                "signature": "(obj: object) -> TypeGuard[Base64FileInput]"
            },
            "is_file_content": {
                "signature": "(obj: object) -> TypeGuard[FileContent]"
            },
            "assert_is_file_content": {
                "signature": "(obj: object) -> None"
            },
            "to_httpx_files": {
                "signature": "(files: RequestFiles | None) -> HttpxRequestFiles | None"
            },
            "_transform_file": {
                "signature": "(file: FileTypes) -> HttpxFileTypes"
            },
            "_read_file_content": {
                "signature": "(file: FileContent) -> HttpxFileContent"
            },
            "async_to_httpx_files": {
                "signature": "async (files: RequestFiles | None) -> HttpxRequestFiles | None"
            },
            "_async_transform_file": {
                "signature": "async (file: FileTypes) -> HttpxFileTypes"
            },
            "_async_read_file_content": {
                "signature": "async (file: FileContent) -> HttpxFileContent"
            }
        }
    },
    "src\\anthropic\\_legacy_response.py": {
        "functions": {
            "to_raw_response_wrapper": {
                "signature": "(func: Callable[P, R]) -> Callable[P, LegacyAPIResponse[R]]",
                "docstring": "Higher order function that takes one of our bound API methods and wraps it\nto support returning the raw `APIResponse` object directly."
            },
            "async_to_raw_response_wrapper": {
                "signature": "(func: Callable[P, Awaitable[R]]) -> Callable[P, Awaitable[LegacyAPIResponse[R]]]",
                "docstring": "Higher order function that takes one of our bound API methods and wraps it\nto support returning the raw `APIResponse` object directly."
            }
        },
        "classes": {
            "LegacyAPIResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "request_id": {
                        "signature": "(self) -> str | None"
                    },
                    "parse": {
                        "signature": "(self) -> R | _T",
                        "docstring": "Returns the rich python representation of this response's data.\n\nNOTE: For the async client: this will become a coroutine in the next major version.\n\nFor lower-level control, see `.read()`, `.json()`, `.iter_bytes()`.\n\nYou can customise the type that the response is parsed into through\nthe `to` argument, e.g.\n\n```py\nfrom anthropic import BaseModel\n\n\nclass MyModel(BaseModel):\n    foo: str\n\n\nobj = response.parse(to=MyModel)\nprint(obj.foo)\n```\n\nWe support parsing:\n  - `BaseModel`\n  - `dict`\n  - `list`\n  - `Union`\n  - `str`\n  - `int`\n  - `float`\n  - `httpx.Response`"
                    },
                    "headers": {
                        "signature": "(self) -> httpx.Headers"
                    },
                    "http_request": {
                        "signature": "(self) -> httpx.Request"
                    },
                    "status_code": {
                        "signature": "(self) -> int"
                    },
                    "url": {
                        "signature": "(self) -> httpx.URL"
                    },
                    "method": {
                        "signature": "(self) -> str"
                    },
                    "content": {
                        "signature": "(self) -> bytes",
                        "docstring": "Return the binary response content.\n\nNOTE: this will be removed in favour of `.read()` in the\nnext major version."
                    },
                    "text": {
                        "signature": "(self) -> str",
                        "docstring": "Return the decoded response content.\n\nNOTE: this will be turned into a method in the next major version."
                    },
                    "http_version": {
                        "signature": "(self) -> str"
                    },
                    "is_closed": {
                        "signature": "(self) -> bool"
                    },
                    "elapsed": {
                        "signature": "(self) -> datetime.timedelta",
                        "docstring": "The time taken for the complete request/response cycle to complete."
                    },
                    "_parse": {
                        "signature": "(self) -> R | _T"
                    },
                    "__repr__": {
                        "signature": "(self) -> str"
                    }
                },
                "docstring": "This is a legacy class as it will be replaced by `APIResponse`\nand `AsyncAPIResponse` in the `_response.py` file in the next major\nrelease.\n\nFor the sync client this will mostly be the same with the exception\nof `content` & `text` will be methods instead of properties. In the\nasync client, all methods will be async.\n\nA migration script will be provided & the migration in general should\nbe smooth."
            },
            "MissingStreamClassError": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    }
                }
            },
            "HttpxBinaryResponseContent": {
                "methods": {
                    "__init__": {
                        "signature": "(self, response: httpx.Response) -> None"
                    },
                    "content": {
                        "signature": "(self) -> bytes"
                    },
                    "text": {
                        "signature": "(self) -> str"
                    },
                    "encoding": {
                        "signature": "(self) -> str | None"
                    },
                    "charset_encoding": {
                        "signature": "(self) -> str | None"
                    },
                    "json": {
                        "signature": "(self, **kwargs: Any) -> Any"
                    },
                    "read": {
                        "signature": "(self) -> bytes"
                    },
                    "iter_bytes": {
                        "signature": "(self, chunk_size=None: int | None) -> Iterator[bytes]"
                    },
                    "iter_text": {
                        "signature": "(self, chunk_size=None: int | None) -> Iterator[str]"
                    },
                    "iter_lines": {
                        "signature": "(self) -> Iterator[str]"
                    },
                    "iter_raw": {
                        "signature": "(self, chunk_size=None: int | None) -> Iterator[bytes]"
                    },
                    "write_to_file": {
                        "signature": "(self, file: str | os.PathLike[str]) -> None",
                        "docstring": "Write the output to the given file.\n\nAccepts a filename or any path-like object, e.g. pathlib.Path\n\nNote: if you want to stream the data to the file instead of writing\nall at once then you should use `.with_streaming_response` when making\nthe API request, e.g. `client.with_streaming_response.foo().stream_to_file('my_filename.txt')`"
                    },
                    "stream_to_file": {
                        "signature": "(self, file: str | os.PathLike[str]) -> None"
                    },
                    "close": {
                        "signature": "(self) -> None"
                    },
                    "aread": {
                        "signature": "async (self) -> bytes"
                    },
                    "aiter_bytes": {
                        "signature": "async (self, chunk_size=None: int | None) -> AsyncIterator[bytes]"
                    },
                    "aiter_text": {
                        "signature": "async (self, chunk_size=None: int | None) -> AsyncIterator[str]"
                    },
                    "aiter_lines": {
                        "signature": "async (self) -> AsyncIterator[str]"
                    },
                    "aiter_raw": {
                        "signature": "async (self, chunk_size=None: int | None) -> AsyncIterator[bytes]"
                    },
                    "astream_to_file": {
                        "signature": "async (self, file: str | os.PathLike[str]) -> None"
                    },
                    "aclose": {
                        "signature": "async (self) -> None"
                    }
                }
            }
        }
    },
    "src\\anthropic\\_models.py": {
        "functions": {
            "_construct_field": {
                "signature": "(value: object, field: FieldInfo, key: str) -> object"
            },
            "is_basemodel": {
                "signature": "(type_: type) -> bool",
                "docstring": "Returns whether or not the given type is either a `BaseModel` or a union of `BaseModel`"
            },
            "is_basemodel_type": {
                "signature": "(type_: type) -> TypeGuard[type[BaseModel] | type[GenericModel]]"
            },
            "build": {
                "signature": "(base_model_cls: Callable[P, _BaseModelT], *args: P.args, **kwargs: P.kwargs) -> _BaseModelT",
                "docstring": "Construct a BaseModel class without validation.\n\nThis is useful for cases where you need to instantiate a `BaseModel`\nfrom an API response as this provides type-safe params which isn't supported\nby helpers like `construct_type()`.\n\n```py\nbuild(MyModel, my_field_a=\"foo\", my_field_b=123)\n```"
            },
            "construct_type_unchecked": {
                "signature": "() -> _T",
                "docstring": "Loose coercion to the expected type with construction of nested values.\n\nNote: the returned value from this function is not guaranteed to match the\ngiven type."
            },
            "construct_type": {
                "signature": "() -> object",
                "docstring": "Loose coercion to the expected type with construction of nested values.\n\nIf the given value does not match the expected type then it is returned as-is."
            },
            "_build_discriminated_union_meta": {
                "signature": "() -> DiscriminatorDetails | None"
            },
            "_extract_field_schema_pv2": {
                "signature": "(model: type[BaseModel], field_name: str) -> ModelField | None"
            },
            "validate_type": {
                "signature": "() -> _T",
                "docstring": "Strict validation that the given value matches the expected type"
            },
            "set_pydantic_config": {
                "signature": "(typ: Any, config: pydantic.ConfigDict) -> None",
                "docstring": "Add a pydantic config for the given type.\n\nNote: this is a no-op on Pydantic v1."
            }
        },
        "classes": {
            "BaseModel": {
                "methods": {
                    "to_dict": {
                        "signature": "(self) -> dict[str, object]",
                        "docstring": "Recursively generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nBy default, fields that were not set by the API will not be included,\nand keys will match the API response, *not* the property names from the model.\n\nFor example, if the API responds with `\"fooBar\": true` but we've defined a `foo_bar: bool` property,\nthe output will use the `\"fooBar\"` key (unless `use_api_names=False` is passed).\n\nArgs:\n    mode:\n        If mode is 'json', the dictionary will only contain JSON serializable types. e.g. `datetime` will be turned into a string, `\"2024-3-22T18:11:19.117000Z\"`.\n        If mode is 'python', the dictionary may contain any Python objects. e.g. `datetime(2024, 3, 22)`\n\n    use_api_names: Whether to use the key that the API responded with or the property name. Defaults to `True`.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value from the output.\n    exclude_none: Whether to exclude fields that have a value of `None` from the output.\n    warnings: Whether to log warnings when invalid fields are encountered. This is only supported in Pydantic v2."
                    },
                    "to_json": {
                        "signature": "(self) -> str",
                        "docstring": "Generates a JSON string representing this model as it would be received from or sent to the API (but with indentation).\n\nBy default, fields that were not set by the API will not be included,\nand keys will match the API response, *not* the property names from the model.\n\nFor example, if the API responds with `\"fooBar\": true` but we've defined a `foo_bar: bool` property,\nthe output will use the `\"fooBar\"` key (unless `use_api_names=False` is passed).\n\nArgs:\n    indent: Indentation to use in the JSON output. If `None` is passed, the output will be compact. Defaults to `2`\n    use_api_names: Whether to use the key that the API responded with or the property name. Defaults to `True`.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that have the default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    warnings: Whether to show any warnings that occurred during serialization. This is only supported in Pydantic v2."
                    },
                    "__str__": {
                        "signature": "(self) -> str"
                    },
                    "construct": {
                        "signature": "(cls: Type[ModelT], _fields_set=None: set[str] | None, **values: object) -> ModelT"
                    }
                }
            },
            "DiscriminatorDetails": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    }
                }
            },
            "FinalRequestOptions": {
                "methods": {
                    "get_max_retries": {
                        "signature": "(self, max_retries: int) -> int"
                    },
                    "_strip_raw_response_header": {
                        "signature": "(self) -> None"
                    },
                    "construct": {
                        "signature": "(cls, _fields_set=None: set[str] | None, **values: Unpack[FinalRequestOptionsInput]) -> FinalRequestOptions"
                    }
                }
            }
        }
    },
    "src\\anthropic\\_qs.py": {
        "classes": {
            "Querystring": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "parse": {
                        "signature": "(self, query: str) -> Mapping[str, object]"
                    },
                    "stringify": {
                        "signature": "(self, params: Params) -> str"
                    },
                    "stringify_items": {
                        "signature": "(self, params: Params) -> list[tuple[str, str]]"
                    },
                    "_stringify_item": {
                        "signature": "(self, key: str, value: Data, opts: Options) -> list[tuple[str, str]]"
                    },
                    "_primitive_value_to_str": {
                        "signature": "(self, value: PrimitiveData) -> str"
                    }
                }
            },
            "Options": {
                "methods": {
                    "__init__": {
                        "signature": "(self, qs=_qs: Querystring) -> None"
                    }
                }
            }
        }
    },
    "src\\anthropic\\_resource.py": {
        "classes": {
            "SyncAPIResource": {
                "methods": {
                    "__init__": {
                        "signature": "(self, client: SyncAPIClient) -> None"
                    },
                    "_sleep": {
                        "signature": "(self, seconds: float) -> None"
                    }
                }
            },
            "AsyncAPIResource": {
                "methods": {
                    "__init__": {
                        "signature": "(self, client: AsyncAPIClient) -> None"
                    },
                    "_sleep": {
                        "signature": "async (self, seconds: float) -> None"
                    }
                }
            }
        }
    },
    "src\\anthropic\\_response.py": {
        "functions": {
            "to_streamed_response_wrapper": {
                "signature": "(func: Callable[P, R]) -> Callable[P, ResponseContextManager[APIResponse[R]]]",
                "docstring": "Higher order function that takes one of our bound API methods and wraps it\nto support streaming and returning the raw `APIResponse` object directly."
            },
            "async_to_streamed_response_wrapper": {
                "signature": "(func: Callable[P, Awaitable[R]]) -> Callable[P, AsyncResponseContextManager[AsyncAPIResponse[R]]]",
                "docstring": "Higher order function that takes one of our bound API methods and wraps it\nto support streaming and returning the raw `APIResponse` object directly."
            },
            "to_custom_streamed_response_wrapper": {
                "signature": "(func: Callable[P, object], response_cls: type[_APIResponseT]) -> Callable[P, ResponseContextManager[_APIResponseT]]",
                "docstring": "Higher order function that takes one of our bound API methods and an `APIResponse` class\nand wraps the method to support streaming and returning the given response class directly.\n\nNote: the given `response_cls` *must* be concrete, e.g. `class BinaryAPIResponse(APIResponse[bytes])`"
            },
            "async_to_custom_streamed_response_wrapper": {
                "signature": "(func: Callable[P, Awaitable[object]], response_cls: type[_AsyncAPIResponseT]) -> Callable[P, AsyncResponseContextManager[_AsyncAPIResponseT]]",
                "docstring": "Higher order function that takes one of our bound API methods and an `APIResponse` class\nand wraps the method to support streaming and returning the given response class directly.\n\nNote: the given `response_cls` *must* be concrete, e.g. `class BinaryAPIResponse(APIResponse[bytes])`"
            },
            "to_raw_response_wrapper": {
                "signature": "(func: Callable[P, R]) -> Callable[P, APIResponse[R]]",
                "docstring": "Higher order function that takes one of our bound API methods and wraps it\nto support returning the raw `APIResponse` object directly."
            },
            "async_to_raw_response_wrapper": {
                "signature": "(func: Callable[P, Awaitable[R]]) -> Callable[P, Awaitable[AsyncAPIResponse[R]]]",
                "docstring": "Higher order function that takes one of our bound API methods and wraps it\nto support returning the raw `APIResponse` object directly."
            },
            "to_custom_raw_response_wrapper": {
                "signature": "(func: Callable[P, object], response_cls: type[_APIResponseT]) -> Callable[P, _APIResponseT]",
                "docstring": "Higher order function that takes one of our bound API methods and an `APIResponse` class\nand wraps the method to support returning the given response class directly.\n\nNote: the given `response_cls` *must* be concrete, e.g. `class BinaryAPIResponse(APIResponse[bytes])`"
            },
            "async_to_custom_raw_response_wrapper": {
                "signature": "(func: Callable[P, Awaitable[object]], response_cls: type[_AsyncAPIResponseT]) -> Callable[P, Awaitable[_AsyncAPIResponseT]]",
                "docstring": "Higher order function that takes one of our bound API methods and an `APIResponse` class\nand wraps the method to support returning the given response class directly.\n\nNote: the given `response_cls` *must* be concrete, e.g. `class BinaryAPIResponse(APIResponse[bytes])`"
            },
            "extract_response_type": {
                "signature": "(typ: type[BaseAPIResponse[Any]]) -> type",
                "docstring": "Given a type like `APIResponse[T]`, returns the generic type variable `T`.\n\nThis also handles the case where a concrete subclass is given, e.g.\n```py\nclass MyResponse(APIResponse[bytes]):\n    ...\n\nextract_response_type(MyResponse) -> bytes\n```"
            }
        },
        "classes": {
            "BaseAPIResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "headers": {
                        "signature": "(self) -> httpx.Headers"
                    },
                    "http_request": {
                        "signature": "(self) -> httpx.Request",
                        "docstring": "Returns the httpx Request instance associated with the current response."
                    },
                    "status_code": {
                        "signature": "(self) -> int"
                    },
                    "url": {
                        "signature": "(self) -> httpx.URL",
                        "docstring": "Returns the URL for which the request was made."
                    },
                    "method": {
                        "signature": "(self) -> str"
                    },
                    "http_version": {
                        "signature": "(self) -> str"
                    },
                    "elapsed": {
                        "signature": "(self) -> datetime.timedelta",
                        "docstring": "The time taken for the complete request/response cycle to complete."
                    },
                    "is_closed": {
                        "signature": "(self) -> bool",
                        "docstring": "Whether or not the response body has been closed.\n\nIf this is False then there is response data that has not been read yet.\nYou must either fully consume the response body or call `.close()`\nbefore discarding the response to prevent resource leaks."
                    },
                    "__repr__": {
                        "signature": "(self) -> str"
                    },
                    "_parse": {
                        "signature": "(self) -> R | _T"
                    }
                }
            },
            "APIResponse": {
                "methods": {
                    "request_id": {
                        "signature": "(self) -> str | None"
                    },
                    "parse": {
                        "signature": "(self) -> R | _T",
                        "docstring": "Returns the rich python representation of this response's data.\n\nFor lower-level control, see `.read()`, `.json()`, `.iter_bytes()`.\n\nYou can customise the type that the response is parsed into through\nthe `to` argument, e.g.\n\n```py\nfrom anthropic import BaseModel\n\n\nclass MyModel(BaseModel):\n    foo: str\n\n\nobj = response.parse(to=MyModel)\nprint(obj.foo)\n```\n\nWe support parsing:\n  - `BaseModel`\n  - `dict`\n  - `list`\n  - `Union`\n  - `str`\n  - `int`\n  - `float`\n  - `httpx.Response`"
                    },
                    "read": {
                        "signature": "(self) -> bytes",
                        "docstring": "Read and return the binary response content."
                    },
                    "text": {
                        "signature": "(self) -> str",
                        "docstring": "Read and decode the response content into a string."
                    },
                    "json": {
                        "signature": "(self) -> object",
                        "docstring": "Read and decode the JSON response content."
                    },
                    "close": {
                        "signature": "(self) -> None",
                        "docstring": "Close the response and release the connection.\n\nAutomatically called if the response body is read to completion."
                    },
                    "iter_bytes": {
                        "signature": "(self, chunk_size=None: int | None) -> Iterator[bytes]",
                        "docstring": "A byte-iterator over the decoded response content.\n\nThis automatically handles gzip, deflate and brotli encoded responses."
                    },
                    "iter_text": {
                        "signature": "(self, chunk_size=None: int | None) -> Iterator[str]",
                        "docstring": "A str-iterator over the decoded response content\nthat handles both gzip, deflate, etc but also detects the content's\nstring encoding."
                    },
                    "iter_lines": {
                        "signature": "(self) -> Iterator[str]",
                        "docstring": "Like `iter_text()` but will only yield chunks for each line"
                    }
                }
            },
            "AsyncAPIResponse": {
                "methods": {
                    "request_id": {
                        "signature": "(self) -> str | None"
                    },
                    "parse": {
                        "signature": "async (self) -> R | _T",
                        "docstring": "Returns the rich python representation of this response's data.\n\nFor lower-level control, see `.read()`, `.json()`, `.iter_bytes()`.\n\nYou can customise the type that the response is parsed into through\nthe `to` argument, e.g.\n\n```py\nfrom anthropic import BaseModel\n\n\nclass MyModel(BaseModel):\n    foo: str\n\n\nobj = response.parse(to=MyModel)\nprint(obj.foo)\n```\n\nWe support parsing:\n  - `BaseModel`\n  - `dict`\n  - `list`\n  - `Union`\n  - `str`\n  - `httpx.Response`"
                    },
                    "read": {
                        "signature": "async (self) -> bytes",
                        "docstring": "Read and return the binary response content."
                    },
                    "text": {
                        "signature": "async (self) -> str",
                        "docstring": "Read and decode the response content into a string."
                    },
                    "json": {
                        "signature": "async (self) -> object",
                        "docstring": "Read and decode the JSON response content."
                    },
                    "close": {
                        "signature": "async (self) -> None",
                        "docstring": "Close the response and release the connection.\n\nAutomatically called if the response body is read to completion."
                    },
                    "iter_bytes": {
                        "signature": "async (self, chunk_size=None: int | None) -> AsyncIterator[bytes]",
                        "docstring": "A byte-iterator over the decoded response content.\n\nThis automatically handles gzip, deflate and brotli encoded responses."
                    },
                    "iter_text": {
                        "signature": "async (self, chunk_size=None: int | None) -> AsyncIterator[str]",
                        "docstring": "A str-iterator over the decoded response content\nthat handles both gzip, deflate, etc but also detects the content's\nstring encoding."
                    },
                    "iter_lines": {
                        "signature": "async (self) -> AsyncIterator[str]",
                        "docstring": "Like `iter_text()` but will only yield chunks for each line"
                    }
                }
            },
            "BinaryAPIResponse": {
                "methods": {
                    "write_to_file": {
                        "signature": "(self, file: str | os.PathLike[str]) -> None",
                        "docstring": "Write the output to the given file.\n\nAccepts a filename or any path-like object, e.g. pathlib.Path\n\nNote: if you want to stream the data to the file instead of writing\nall at once then you should use `.with_streaming_response` when making\nthe API request, e.g. `.with_streaming_response.get_binary_response()`"
                    }
                },
                "docstring": "Subclass of APIResponse providing helpers for dealing with binary data.\n\nNote: If you want to stream the response data instead of eagerly reading it\nall at once then you should use `.with_streaming_response` when making\nthe API request, e.g. `.with_streaming_response.get_binary_response()`"
            },
            "AsyncBinaryAPIResponse": {
                "methods": {
                    "write_to_file": {
                        "signature": "async (self, file: str | os.PathLike[str]) -> None",
                        "docstring": "Write the output to the given file.\n\nAccepts a filename or any path-like object, e.g. pathlib.Path\n\nNote: if you want to stream the data to the file instead of writing\nall at once then you should use `.with_streaming_response` when making\nthe API request, e.g. `.with_streaming_response.get_binary_response()`"
                    }
                },
                "docstring": "Subclass of APIResponse providing helpers for dealing with binary data.\n\nNote: If you want to stream the response data instead of eagerly reading it\nall at once then you should use `.with_streaming_response` when making\nthe API request, e.g. `.with_streaming_response.get_binary_response()`"
            },
            "StreamedBinaryAPIResponse": {
                "methods": {
                    "stream_to_file": {
                        "signature": "(self, file: str | os.PathLike[str]) -> None",
                        "docstring": "Streams the output to the given file.\n\nAccepts a filename or any path-like object, e.g. pathlib.Path"
                    }
                }
            },
            "AsyncStreamedBinaryAPIResponse": {
                "methods": {
                    "stream_to_file": {
                        "signature": "async (self, file: str | os.PathLike[str]) -> None",
                        "docstring": "Streams the output to the given file.\n\nAccepts a filename or any path-like object, e.g. pathlib.Path"
                    }
                }
            },
            "MissingStreamClassError": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    }
                }
            },
            "StreamAlreadyConsumed": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    }
                },
                "docstring": "Attempted to read or stream content, but the content has already\nbeen streamed.\n\nThis can happen if you use a method like `.iter_lines()` and then attempt\nto read th entire response body afterwards, e.g.\n\n```py\nresponse = await client.post(...)\nasync for line in response.iter_lines():\n    ...  # do something with `line`\n\ncontent = await response.read()\n# ^ error\n```\n\nIf you want this behaviour you'll need to either manually accumulate the response\ncontent or call `await response.read()` before iterating over the stream."
            },
            "ResponseContextManager": {
                "methods": {
                    "__init__": {
                        "signature": "(self, request_func: Callable[[], _APIResponseT]) -> None"
                    },
                    "__enter__": {
                        "signature": "(self) -> _APIResponseT"
                    },
                    "__exit__": {
                        "signature": "(self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None"
                    }
                },
                "docstring": "Context manager for ensuring that a request is not made\nuntil it is entered and that the response will always be closed\nwhen the context manager exits"
            },
            "AsyncResponseContextManager": {
                "methods": {
                    "__init__": {
                        "signature": "(self, api_request: Awaitable[_AsyncAPIResponseT]) -> None"
                    },
                    "__aenter__": {
                        "signature": "async (self) -> _AsyncAPIResponseT"
                    },
                    "__aexit__": {
                        "signature": "async (self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None"
                    }
                },
                "docstring": "Context manager for ensuring that a request is not made\nuntil it is entered and that the response will always be closed\nwhen the context manager exits"
            }
        }
    },
    "src\\anthropic\\_streaming.py": {
        "functions": {
            "is_stream_class_type": {
                "signature": "(typ: type) -> TypeGuard[type[Stream[object]] | type[AsyncStream[object]]]",
                "docstring": "TypeGuard for determining whether or not the given type is a subclass of `Stream` / `AsyncStream`"
            },
            "extract_stream_chunk_type": {
                "signature": "(stream_cls: type) -> type",
                "docstring": "Given a type like `Stream[T]`, returns the generic type variable `T`.\n\nThis also handles the case where a concrete subclass is given, e.g.\n```py\nclass MyStream(Stream[bytes]):\n    ...\n\nextract_stream_chunk_type(MyStream) -> bytes\n```"
            }
        },
        "classes": {
            "_SyncStreamMeta": {
                "methods": {
                    "__instancecheck__": {
                        "signature": "(self, instance: Any) -> bool"
                    }
                }
            },
            "Stream": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "__next__": {
                        "signature": "(self) -> _T"
                    },
                    "__iter__": {
                        "signature": "(self) -> Iterator[_T]"
                    },
                    "_iter_events": {
                        "signature": "(self) -> Iterator[ServerSentEvent]"
                    },
                    "__stream__": {
                        "signature": "(self) -> Iterator[_T]"
                    },
                    "__enter__": {
                        "signature": "(self) -> Self"
                    },
                    "__exit__": {
                        "signature": "(self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None"
                    },
                    "close": {
                        "signature": "(self) -> None",
                        "docstring": "Close the response and release the connection.\n\nAutomatically called if the response body is read to completion."
                    }
                },
                "docstring": "Provides the core interface to iterate over a synchronous stream response."
            },
            "_AsyncStreamMeta": {
                "methods": {
                    "__instancecheck__": {
                        "signature": "(self, instance: Any) -> bool"
                    }
                }
            },
            "AsyncStream": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "__anext__": {
                        "signature": "async (self) -> _T"
                    },
                    "__aiter__": {
                        "signature": "async (self) -> AsyncIterator[_T]"
                    },
                    "_iter_events": {
                        "signature": "async (self) -> AsyncIterator[ServerSentEvent]"
                    },
                    "__stream__": {
                        "signature": "async (self) -> AsyncIterator[_T]"
                    },
                    "__aenter__": {
                        "signature": "async (self) -> Self"
                    },
                    "__aexit__": {
                        "signature": "async (self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None"
                    },
                    "close": {
                        "signature": "async (self) -> None",
                        "docstring": "Close the response and release the connection.\n\nAutomatically called if the response body is read to completion."
                    }
                },
                "docstring": "Provides the core interface to iterate over an asynchronous stream response."
            },
            "ServerSentEvent": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "event": {
                        "signature": "(self) -> str | None"
                    },
                    "id": {
                        "signature": "(self) -> str | None"
                    },
                    "retry": {
                        "signature": "(self) -> int | None"
                    },
                    "data": {
                        "signature": "(self) -> str"
                    },
                    "json": {
                        "signature": "(self) -> Any"
                    },
                    "__repr__": {
                        "signature": "(self) -> str"
                    }
                }
            },
            "SSEDecoder": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "iter_bytes": {
                        "signature": "(self, iterator: Iterator[bytes]) -> Iterator[ServerSentEvent]",
                        "docstring": "Given an iterator that yields raw binary data, iterate over it & yield every event encountered"
                    },
                    "_iter_chunks": {
                        "signature": "(self, iterator: Iterator[bytes]) -> Iterator[bytes]",
                        "docstring": "Given an iterator that yields raw binary data, iterate over it and yield individual SSE chunks"
                    },
                    "aiter_bytes": {
                        "signature": "async (self, iterator: AsyncIterator[bytes]) -> AsyncIterator[ServerSentEvent]",
                        "docstring": "Given an iterator that yields raw binary data, iterate over it & yield every event encountered"
                    },
                    "_aiter_chunks": {
                        "signature": "async (self, iterator: AsyncIterator[bytes]) -> AsyncIterator[bytes]",
                        "docstring": "Given an iterator that yields raw binary data, iterate over it and yield individual SSE chunks"
                    },
                    "decode": {
                        "signature": "(self, line: str) -> ServerSentEvent | None"
                    }
                }
            },
            "SSEBytesDecoder": {
                "methods": {
                    "iter_bytes": {
                        "signature": "(self, iterator: Iterator[bytes]) -> Iterator[ServerSentEvent]",
                        "docstring": "Given an iterator that yields raw binary data, iterate over it & yield every event encountered"
                    },
                    "aiter_bytes": {
                        "signature": "(self, iterator: AsyncIterator[bytes]) -> AsyncIterator[ServerSentEvent]",
                        "docstring": "Given an async iterator that yields raw binary data, iterate over it & yield every event encountered"
                    }
                }
            }
        }
    },
    "src\\anthropic\\_tokenizers.py": {
        "functions": {
            "_get_tokenizer_cache_path": {
                "signature": "() -> Path"
            },
            "_load_tokenizer": {
                "signature": "(raw: str) -> TokenizerType"
            },
            "sync_get_tokenizer": {
                "signature": "() -> TokenizerType"
            },
            "async_get_tokenizer": {
                "signature": "async () -> TokenizerType"
            }
        }
    },
    "src\\anthropic\\_types.py": {
        "classes": {
            "NotGiven": {
                "methods": {
                    "__bool__": {
                        "signature": "(self) -> Literal[False]"
                    },
                    "__repr__": {
                        "signature": "(self) -> str"
                    }
                },
                "docstring": "A sentinel singleton class used to distinguish omitted keyword arguments\nfrom those passed in with the value None (which may have different behavior).\n\nFor example:\n\n```py\ndef get(timeout: Union[int, NotGiven, None] = NotGiven()) -> Response: ...\n\n\nget(timeout=1)  # 1s timeout\nget(timeout=None)  # No timeout\nget()  # Default timeout behavior, which may not be statically known at the method definition.\n```"
            },
            "Omit": {
                "methods": {
                    "__bool__": {
                        "signature": "(self) -> Literal[False]"
                    }
                },
                "docstring": "In certain situations you need to be able to represent a case where a default value has\nto be explicitly removed and `None` is not an appropriate substitute, for example:\n\n```py\n# as the default `Content-Type` header is `application/json` that will be sent\nclient.post(\"/upload/files\", files={\"file\": b\"my raw file content\"})\n\n# you can't explicitly override the header as it has to be dynamically generated\n# to look something like: 'multipart/form-data; boundary=0d8382fcf5f8c3be01ca2e11002d2983'\nclient.post(..., headers={\"Content-Type\": \"multipart/form-data\"})\n\n# instead you can remove the default `application/json` header by passing Omit\nclient.post(..., headers={\"Content-Type\": Omit()})\n```"
            },
            "ModelBuilderProtocol": {
                "methods": {
                    "build": {
                        "signature": "(cls: type[_T]) -> _T"
                    }
                }
            },
            "HeadersLikeProtocol": {
                "methods": {
                    "get": {
                        "signature": "(self, __key: str) -> str | None"
                    }
                }
            },
            "InheritsGeneric": {
                "docstring": "Represents a type that has inherited from `Generic`\n\nThe `__orig_bases__` property can be used to determine the resolved\ntype variable for a given base class."
            }
        }
    },
    "src\\anthropic\\lib\\bedrock\\_auth.py": {
        "functions": {
            "_get_session": {
                "signature": "() -> boto3.Session"
            },
            "get_auth_headers": {
                "signature": "() -> dict[str, str]"
            }
        }
    },
    "src\\anthropic\\lib\\bedrock\\_beta.py": {
        "classes": {
            "Beta": {
                "methods": {
                    "messages": {
                        "signature": "(self) -> Messages"
                    },
                    "with_raw_response": {
                        "signature": "(self) -> BetaWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> BetaWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    }
                }
            },
            "AsyncBeta": {
                "methods": {
                    "messages": {
                        "signature": "(self) -> AsyncMessages"
                    },
                    "with_raw_response": {
                        "signature": "(self) -> AsyncBetaWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> AsyncBetaWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    }
                }
            },
            "BetaWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, beta: Beta) -> None"
                    },
                    "messages": {
                        "signature": "(self) -> MessagesWithRawResponse"
                    }
                }
            },
            "AsyncBetaWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, beta: AsyncBeta) -> None"
                    },
                    "messages": {
                        "signature": "(self) -> AsyncMessagesWithRawResponse"
                    }
                }
            },
            "BetaWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, beta: Beta) -> None"
                    },
                    "messages": {
                        "signature": "(self) -> MessagesWithStreamingResponse"
                    }
                }
            },
            "AsyncBetaWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, beta: AsyncBeta) -> None"
                    },
                    "messages": {
                        "signature": "(self) -> AsyncMessagesWithStreamingResponse"
                    }
                }
            }
        }
    },
    "src\\anthropic\\lib\\bedrock\\_beta_messages.py": {
        "classes": {
            "Messages": {
                "methods": {
                    "with_raw_response": {
                        "signature": "(self) -> MessagesWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> MessagesWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    }
                }
            },
            "AsyncMessages": {
                "methods": {
                    "with_raw_response": {
                        "signature": "(self) -> AsyncMessagesWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> AsyncMessagesWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    }
                }
            },
            "MessagesWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: Messages) -> None"
                    }
                }
            },
            "AsyncMessagesWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: AsyncMessages) -> None"
                    }
                }
            },
            "MessagesWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: Messages) -> None"
                    }
                }
            },
            "AsyncMessagesWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: AsyncMessages) -> None"
                    }
                }
            }
        }
    },
    "src\\anthropic\\lib\\bedrock\\_client.py": {
        "functions": {
            "_prepare_options": {
                "signature": "(input_options: FinalRequestOptions) -> FinalRequestOptions"
            }
        },
        "classes": {
            "BaseBedrockClient": {
                "methods": {
                    "_make_status_error": {
                        "signature": "(self, err_msg: str) -> APIStatusError"
                    }
                }
            },
            "AnthropicBedrock": {
                "methods": {
                    "__init__": {
                        "signature": "(self, aws_secret_key=None: str | None, aws_access_key=None: str | None, aws_region=None: str | None, aws_profile=None: str | None, aws_session_token=None: str | None, base_url=None: str | httpx.URL | None, timeout=NOT_GIVEN: float | httpx.Timeout | None | NotGiven, max_retries=DEFAULT_MAX_RETRIES: int, default_headers=None: Mapping[str, str] | None, default_query=None: Mapping[str, object] | None, http_client=None: httpx.Client | None, _strict_response_validation=False: bool) -> None"
                    },
                    "_make_sse_decoder": {
                        "signature": "(self) -> AWSEventStreamDecoder"
                    },
                    "_prepare_options": {
                        "signature": "(self, options: FinalRequestOptions) -> FinalRequestOptions"
                    },
                    "_prepare_request": {
                        "signature": "(self, request: httpx.Request) -> None"
                    },
                    "copy": {
                        "signature": "(self) -> Self",
                        "docstring": "Create a new client instance re-using the same options given to the current client with optional overriding."
                    }
                }
            },
            "AsyncAnthropicBedrock": {
                "methods": {
                    "__init__": {
                        "signature": "(self, aws_secret_key=None: str | None, aws_access_key=None: str | None, aws_region=None: str | None, aws_profile=None: str | None, aws_session_token=None: str | None, base_url=None: str | httpx.URL | None, timeout=NOT_GIVEN: float | httpx.Timeout | None | NotGiven, max_retries=DEFAULT_MAX_RETRIES: int, default_headers=None: Mapping[str, str] | None, default_query=None: Mapping[str, object] | None, http_client=None: httpx.AsyncClient | None, _strict_response_validation=False: bool) -> None"
                    },
                    "_make_sse_decoder": {
                        "signature": "(self) -> AWSEventStreamDecoder"
                    },
                    "_prepare_options": {
                        "signature": "async (self, options: FinalRequestOptions) -> FinalRequestOptions"
                    },
                    "_prepare_request": {
                        "signature": "async (self, request: httpx.Request) -> None"
                    },
                    "copy": {
                        "signature": "(self) -> Self",
                        "docstring": "Create a new client instance re-using the same options given to the current client with optional overriding."
                    }
                }
            }
        }
    },
    "src\\anthropic\\lib\\bedrock\\_stream.py": {
        "classes": {
            "BedrockStream": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    }
                }
            },
            "AsyncBedrockStream": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    }
                }
            }
        }
    },
    "src\\anthropic\\lib\\bedrock\\_stream_decoder.py": {
        "functions": {
            "get_response_stream_shape": {
                "signature": "() -> Shape"
            }
        },
        "classes": {
            "AWSEventStreamDecoder": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "iter_bytes": {
                        "signature": "(self, iterator: Iterator[bytes]) -> Iterator[ServerSentEvent]",
                        "docstring": "Given an iterator that yields lines, iterate over it & yield every event encountered"
                    },
                    "aiter_bytes": {
                        "signature": "async (self, iterator: AsyncIterator[bytes]) -> AsyncIterator[ServerSentEvent]",
                        "docstring": "Given an async iterator that yields lines, iterate over it & yield every event encountered"
                    },
                    "_parse_message_from_event": {
                        "signature": "(self, event: EventStreamMessage) -> str | None"
                    }
                }
            }
        }
    },
    "src\\anthropic\\lib\\streaming\\_messages.py": {
        "functions": {
            "build_events": {
                "signature": "() -> list[MessageStreamEvent]"
            },
            "accumulate_event": {
                "signature": "() -> Message"
            }
        },
        "classes": {
            "MessageStream": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "__next__": {
                        "signature": "(self) -> MessageStreamEvent"
                    },
                    "__iter__": {
                        "signature": "(self) -> Iterator[MessageStreamEvent]"
                    },
                    "__enter__": {
                        "signature": "(self) -> Self"
                    },
                    "__exit__": {
                        "signature": "(self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None"
                    },
                    "close": {
                        "signature": "(self) -> None",
                        "docstring": "Close the response and release the connection.\n\nAutomatically called if the response body is read to completion."
                    },
                    "get_final_message": {
                        "signature": "(self) -> Message",
                        "docstring": "Waits until the stream has been read to completion and returns\nthe accumulated `Message` object."
                    },
                    "get_final_text": {
                        "signature": "(self) -> str",
                        "docstring": "Returns all `text` content blocks concatenated together.\n\n> [!NOTE]\n> Currently the API will only respond with a single content block.\n\nWill raise an error if no `text` content blocks were returned."
                    },
                    "until_done": {
                        "signature": "(self) -> None",
                        "docstring": "Blocks until the stream has been consumed"
                    },
                    "current_message_snapshot": {
                        "signature": "(self) -> Message"
                    },
                    "__stream__": {
                        "signature": "(self) -> Iterator[MessageStreamEvent]"
                    },
                    "__stream_text__": {
                        "signature": "(self) -> Iterator[str]"
                    }
                }
            },
            "MessageStreamManager": {
                "methods": {
                    "__init__": {
                        "signature": "(self, api_request: Callable[[], Stream[RawMessageStreamEvent]]) -> None"
                    },
                    "__enter__": {
                        "signature": "(self) -> MessageStream"
                    },
                    "__exit__": {
                        "signature": "(self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None"
                    }
                },
                "docstring": "Wrapper over MessageStream that is returned by `.stream()`.\n\n```py\nwith client.messages.stream(...) as stream:\n    for chunk in stream:\n        ...\n```"
            },
            "AsyncMessageStream": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "__anext__": {
                        "signature": "async (self) -> MessageStreamEvent"
                    },
                    "__aiter__": {
                        "signature": "async (self) -> AsyncIterator[MessageStreamEvent]"
                    },
                    "__aenter__": {
                        "signature": "async (self) -> Self"
                    },
                    "__aexit__": {
                        "signature": "async (self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None"
                    },
                    "close": {
                        "signature": "async (self) -> None",
                        "docstring": "Close the response and release the connection.\n\nAutomatically called if the response body is read to completion."
                    },
                    "get_final_message": {
                        "signature": "async (self) -> Message",
                        "docstring": "Waits until the stream has been read to completion and returns\nthe accumulated `Message` object."
                    },
                    "get_final_text": {
                        "signature": "async (self) -> str",
                        "docstring": "Returns all `text` content blocks concatenated together.\n\n> [!NOTE]\n> Currently the API will only respond with a single content block.\n\nWill raise an error if no `text` content blocks were returned."
                    },
                    "until_done": {
                        "signature": "async (self) -> None",
                        "docstring": "Waits until the stream has been consumed"
                    },
                    "current_message_snapshot": {
                        "signature": "(self) -> Message"
                    },
                    "__stream__": {
                        "signature": "async (self) -> AsyncIterator[MessageStreamEvent]"
                    },
                    "__stream_text__": {
                        "signature": "async (self) -> AsyncIterator[str]"
                    }
                }
            },
            "AsyncMessageStreamManager": {
                "methods": {
                    "__init__": {
                        "signature": "(self, api_request: Awaitable[AsyncStream[RawMessageStreamEvent]]) -> None"
                    },
                    "__aenter__": {
                        "signature": "async (self) -> AsyncMessageStream"
                    },
                    "__aexit__": {
                        "signature": "async (self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None"
                    }
                },
                "docstring": "Wrapper over AsyncMessageStream that is returned by `.stream()`\nso that an async context manager can be used without `await`ing the\noriginal client call.\n\n```py\nasync with client.messages.stream(...) as stream:\n    async for chunk in stream:\n        ...\n```"
            }
        }
    },
    "src\\anthropic\\lib\\streaming\\_prompt_caching_beta_messages.py": {
        "functions": {
            "build_events": {
                "signature": "() -> list[PromptCachingBetaMessageStreamEvent]"
            },
            "accumulate_event": {
                "signature": "() -> PromptCachingBetaMessage"
            }
        },
        "classes": {
            "PromptCachingBetaMessageStream": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "__next__": {
                        "signature": "(self) -> PromptCachingBetaMessageStreamEvent"
                    },
                    "__iter__": {
                        "signature": "(self) -> Iterator[PromptCachingBetaMessageStreamEvent]"
                    },
                    "__enter__": {
                        "signature": "(self) -> Self"
                    },
                    "__exit__": {
                        "signature": "(self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None"
                    },
                    "close": {
                        "signature": "(self) -> None",
                        "docstring": "Close the response and release the connection.\n\nAutomatically called if the response body is read to completion."
                    },
                    "get_final_message": {
                        "signature": "(self) -> PromptCachingBetaMessage",
                        "docstring": "Waits until the stream has been read to completion and returns\nthe accumulated `PromptCachingBetaMessage` object."
                    },
                    "get_final_text": {
                        "signature": "(self) -> str",
                        "docstring": "Returns all `text` content blocks concatenated together.\n\n> [!NOTE]\n> Currently the API will only respond with a single content block.\n\nWill raise an error if no `text` content blocks were returned."
                    },
                    "until_done": {
                        "signature": "(self) -> None",
                        "docstring": "Blocks until the stream has been consumed"
                    },
                    "current_message_snapshot": {
                        "signature": "(self) -> PromptCachingBetaMessage"
                    },
                    "__stream__": {
                        "signature": "(self) -> Iterator[PromptCachingBetaMessageStreamEvent]"
                    },
                    "__stream_text__": {
                        "signature": "(self) -> Iterator[str]"
                    }
                }
            },
            "PromptCachingBetaMessageStreamManager": {
                "methods": {
                    "__init__": {
                        "signature": "(self, api_request: Callable[[], Stream[RawPromptCachingBetaMessageStreamEvent]]) -> None"
                    },
                    "__enter__": {
                        "signature": "(self) -> PromptCachingBetaMessageStream"
                    },
                    "__exit__": {
                        "signature": "(self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None"
                    }
                },
                "docstring": "Wrapper over PromptCachingBetaMessageStream that is returned by `.stream()`.\n\n```py\nwith client.beta.prompt_caching.messages.stream(...) as stream:\n    for chunk in stream:\n        ...\n```"
            },
            "AsyncPromptCachingBetaMessageStream": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "__anext__": {
                        "signature": "async (self) -> PromptCachingBetaMessageStreamEvent"
                    },
                    "__aiter__": {
                        "signature": "async (self) -> AsyncIterator[PromptCachingBetaMessageStreamEvent]"
                    },
                    "__aenter__": {
                        "signature": "async (self) -> Self"
                    },
                    "__aexit__": {
                        "signature": "async (self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None"
                    },
                    "close": {
                        "signature": "async (self) -> None",
                        "docstring": "Close the response and release the connection.\n\nAutomatically called if the response body is read to completion."
                    },
                    "get_final_message": {
                        "signature": "async (self) -> PromptCachingBetaMessage",
                        "docstring": "Waits until the stream has been read to completion and returns\nthe accumulated `PromptCachingBetaMessage` object."
                    },
                    "get_final_text": {
                        "signature": "async (self) -> str",
                        "docstring": "Returns all `text` content blocks concatenated together.\n\n> [!NOTE]\n> Currently the API will only respond with a single content block.\n\nWill raise an error if no `text` content blocks were returned."
                    },
                    "until_done": {
                        "signature": "async (self) -> None",
                        "docstring": "Waits until the stream has been consumed"
                    },
                    "current_message_snapshot": {
                        "signature": "(self) -> PromptCachingBetaMessage"
                    },
                    "__stream__": {
                        "signature": "async (self) -> AsyncIterator[PromptCachingBetaMessageStreamEvent]"
                    },
                    "__stream_text__": {
                        "signature": "async (self) -> AsyncIterator[str]"
                    }
                }
            },
            "AsyncPromptCachingBetaMessageStreamManager": {
                "methods": {
                    "__init__": {
                        "signature": "(self, api_request: Awaitable[AsyncStream[RawPromptCachingBetaMessageStreamEvent]]) -> None"
                    },
                    "__aenter__": {
                        "signature": "async (self) -> AsyncPromptCachingBetaMessageStream"
                    },
                    "__aexit__": {
                        "signature": "async (self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None"
                    }
                },
                "docstring": "Wrapper over AsyncMessageStream that is returned by `.stream()`\nso that an async context manager can be used without `await`ing the\noriginal client call.\n\n```py\nasync with client.messages.stream(...) as stream:\n    async for chunk in stream:\n        ...\n```"
            }
        }
    },
    "src\\anthropic\\lib\\streaming\\_prompt_caching_beta_types.py": {
        "classes": {}
    },
    "src\\anthropic\\lib\\streaming\\_types.py": {
        "classes": {}
    },
    "src\\anthropic\\lib\\vertex\\_auth.py": {
        "functions": {
            "load_auth": {
                "signature": "() -> tuple[Credentials, str]"
            },
            "refresh_auth": {
                "signature": "(credentials: Credentials) -> None"
            }
        }
    },
    "src\\anthropic\\lib\\vertex\\_beta.py": {
        "classes": {
            "Beta": {
                "methods": {
                    "messages": {
                        "signature": "(self) -> Messages"
                    },
                    "with_raw_response": {
                        "signature": "(self) -> BetaWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> BetaWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    }
                }
            },
            "AsyncBeta": {
                "methods": {
                    "messages": {
                        "signature": "(self) -> AsyncMessages"
                    },
                    "with_raw_response": {
                        "signature": "(self) -> AsyncBetaWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> AsyncBetaWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    }
                }
            },
            "BetaWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, beta: Beta) -> None"
                    },
                    "messages": {
                        "signature": "(self) -> MessagesWithRawResponse"
                    }
                }
            },
            "AsyncBetaWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, beta: AsyncBeta) -> None"
                    },
                    "messages": {
                        "signature": "(self) -> AsyncMessagesWithRawResponse"
                    }
                }
            },
            "BetaWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, beta: Beta) -> None"
                    },
                    "messages": {
                        "signature": "(self) -> MessagesWithStreamingResponse"
                    }
                }
            },
            "AsyncBetaWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, beta: AsyncBeta) -> None"
                    },
                    "messages": {
                        "signature": "(self) -> AsyncMessagesWithStreamingResponse"
                    }
                }
            }
        }
    },
    "src\\anthropic\\lib\\vertex\\_beta_messages.py": {
        "classes": {
            "Messages": {
                "methods": {
                    "with_raw_response": {
                        "signature": "(self) -> MessagesWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> MessagesWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    }
                }
            },
            "AsyncMessages": {
                "methods": {
                    "with_raw_response": {
                        "signature": "(self) -> AsyncMessagesWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> AsyncMessagesWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    }
                }
            },
            "MessagesWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: Messages) -> None"
                    }
                }
            },
            "AsyncMessagesWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: AsyncMessages) -> None"
                    }
                }
            },
            "MessagesWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: Messages) -> None"
                    }
                }
            },
            "AsyncMessagesWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: AsyncMessages) -> None"
                    }
                }
            }
        }
    },
    "src\\anthropic\\lib\\vertex\\_client.py": {
        "functions": {
            "_prepare_options": {
                "signature": "(input_options: FinalRequestOptions) -> FinalRequestOptions"
            }
        },
        "classes": {
            "BaseVertexClient": {
                "methods": {
                    "region": {
                        "signature": "(self) -> str"
                    },
                    "project_id": {
                        "signature": "(self) -> str | None"
                    },
                    "_make_status_error": {
                        "signature": "(self, err_msg: str) -> APIStatusError"
                    }
                }
            },
            "AnthropicVertex": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "_prepare_options": {
                        "signature": "(self, options: FinalRequestOptions) -> FinalRequestOptions"
                    },
                    "_prepare_request": {
                        "signature": "(self, request: httpx.Request) -> None"
                    },
                    "_ensure_access_token": {
                        "signature": "(self) -> str"
                    },
                    "copy": {
                        "signature": "(self) -> Self",
                        "docstring": "Create a new client instance re-using the same options given to the current client with optional overriding."
                    }
                }
            },
            "AsyncAnthropicVertex": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "_prepare_options": {
                        "signature": "async (self, options: FinalRequestOptions) -> FinalRequestOptions"
                    },
                    "_prepare_request": {
                        "signature": "async (self, request: httpx.Request) -> None"
                    },
                    "_ensure_access_token": {
                        "signature": "async (self) -> str"
                    },
                    "copy": {
                        "signature": "(self) -> Self",
                        "docstring": "Create a new client instance re-using the same options given to the current client with optional overriding."
                    }
                }
            }
        }
    },
    "src\\anthropic\\lib\\_extras\\_common.py": {
        "classes": {
            "MissingDependencyError": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    }
                }
            }
        }
    },
    "src\\anthropic\\lib\\_extras\\_google_auth.py": {
        "classes": {
            "GoogleAuthProxy": {
                "methods": {
                    "__load__": {
                        "signature": "(self) -> Any"
                    }
                }
            }
        }
    },
    "src\\anthropic\\resources\\completions.py": {
        "classes": {
            "Completions": {
                "methods": {
                    "with_raw_response": {
                        "signature": "(self) -> CompletionsWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> CompletionsWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    },
                    "create": {
                        "signature": "(self) -> Completion | Stream[Completion]"
                    }
                }
            },
            "AsyncCompletions": {
                "methods": {
                    "with_raw_response": {
                        "signature": "(self) -> AsyncCompletionsWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> AsyncCompletionsWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    },
                    "create": {
                        "signature": "async (self) -> Completion | AsyncStream[Completion]"
                    }
                }
            },
            "CompletionsWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, completions: Completions) -> None"
                    }
                }
            },
            "AsyncCompletionsWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, completions: AsyncCompletions) -> None"
                    }
                }
            },
            "CompletionsWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, completions: Completions) -> None"
                    }
                }
            },
            "AsyncCompletionsWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, completions: AsyncCompletions) -> None"
                    }
                }
            }
        }
    },
    "src\\anthropic\\resources\\messages.py": {
        "classes": {
            "Messages": {
                "methods": {
                    "with_raw_response": {
                        "signature": "(self) -> MessagesWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> MessagesWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    },
                    "create": {
                        "signature": "(self) -> Message | Stream[RawMessageStreamEvent]"
                    },
                    "stream": {
                        "signature": "(self) -> MessageStreamManager",
                        "docstring": "Create a Message stream"
                    }
                }
            },
            "AsyncMessages": {
                "methods": {
                    "with_raw_response": {
                        "signature": "(self) -> AsyncMessagesWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> AsyncMessagesWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    },
                    "create": {
                        "signature": "async (self) -> Message | AsyncStream[RawMessageStreamEvent]"
                    },
                    "stream": {
                        "signature": "(self) -> AsyncMessageStreamManager",
                        "docstring": "Create a Message stream"
                    }
                }
            },
            "MessagesWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: Messages) -> None"
                    }
                }
            },
            "AsyncMessagesWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: AsyncMessages) -> None"
                    }
                }
            },
            "MessagesWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: Messages) -> None"
                    }
                }
            },
            "AsyncMessagesWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: AsyncMessages) -> None"
                    }
                }
            }
        }
    },
    "src\\anthropic\\resources\\beta\\beta.py": {
        "classes": {
            "Beta": {
                "methods": {
                    "messages": {
                        "signature": "(self) -> Messages"
                    },
                    "prompt_caching": {
                        "signature": "(self) -> PromptCaching"
                    },
                    "with_raw_response": {
                        "signature": "(self) -> BetaWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> BetaWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    }
                }
            },
            "AsyncBeta": {
                "methods": {
                    "messages": {
                        "signature": "(self) -> AsyncMessages"
                    },
                    "prompt_caching": {
                        "signature": "(self) -> AsyncPromptCaching"
                    },
                    "with_raw_response": {
                        "signature": "(self) -> AsyncBetaWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> AsyncBetaWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    }
                }
            },
            "BetaWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, beta: Beta) -> None"
                    },
                    "messages": {
                        "signature": "(self) -> MessagesWithRawResponse"
                    },
                    "prompt_caching": {
                        "signature": "(self) -> PromptCachingWithRawResponse"
                    }
                }
            },
            "AsyncBetaWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, beta: AsyncBeta) -> None"
                    },
                    "messages": {
                        "signature": "(self) -> AsyncMessagesWithRawResponse"
                    },
                    "prompt_caching": {
                        "signature": "(self) -> AsyncPromptCachingWithRawResponse"
                    }
                }
            },
            "BetaWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, beta: Beta) -> None"
                    },
                    "messages": {
                        "signature": "(self) -> MessagesWithStreamingResponse"
                    },
                    "prompt_caching": {
                        "signature": "(self) -> PromptCachingWithStreamingResponse"
                    }
                }
            },
            "AsyncBetaWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, beta: AsyncBeta) -> None"
                    },
                    "messages": {
                        "signature": "(self) -> AsyncMessagesWithStreamingResponse"
                    },
                    "prompt_caching": {
                        "signature": "(self) -> AsyncPromptCachingWithStreamingResponse"
                    }
                }
            }
        }
    },
    "src\\anthropic\\resources\\beta\\messages\\batches.py": {
        "classes": {
            "Batches": {
                "methods": {
                    "with_raw_response": {
                        "signature": "(self) -> BatchesWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> BatchesWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    },
                    "create": {
                        "signature": "(self) -> BetaMessageBatch",
                        "docstring": "Send a batch of Message creation requests.\n\nThe Message Batches API can be used to process multiple Messages API requests at\nonce. Once a Message Batch is created, it begins processing immediately. Batches\ncan take up to 24 hours to complete.\n\nArgs:\n  requests: List of requests for prompt completion. Each is an individual request to create\n      a Message.\n\n  betas: Optional header to specify the beta version(s) you want to use.\n\n  extra_headers: Send extra headers\n\n  extra_query: Add additional query parameters to the request\n\n  extra_body: Add additional JSON properties to the request\n\n  timeout: Override the client-level default timeout for this request, in seconds"
                    },
                    "retrieve": {
                        "signature": "(self, message_batch_id: str) -> BetaMessageBatch",
                        "docstring": "This endpoint is idempotent and can be used to poll for Message Batch\ncompletion.\n\nTo access the results of a Message Batch, make a request to the\n`results_url` field in the response.\n\nArgs:\n  message_batch_id: ID of the Message Batch.\n\n  betas: Optional header to specify the beta version(s) you want to use.\n\n  extra_headers: Send extra headers\n\n  extra_query: Add additional query parameters to the request\n\n  extra_body: Add additional JSON properties to the request\n\n  timeout: Override the client-level default timeout for this request, in seconds"
                    },
                    "list": {
                        "signature": "(self) -> SyncPage[BetaMessageBatch]",
                        "docstring": "List all Message Batches within a Workspace.\n\nMost recently created batches are\nreturned first.\n\nArgs:\n  after_id: ID of the object to use as a cursor for pagination. When provided, returns the\n      page of results immediately after this object.\n\n  before_id: ID of the object to use as a cursor for pagination. When provided, returns the\n      page of results immediately before this object.\n\n  limit: Number of items to return per page.\n\n      Defaults to `20`. Ranges from `1` to `100`.\n\n  betas: Optional header to specify the beta version(s) you want to use.\n\n  extra_headers: Send extra headers\n\n  extra_query: Add additional query parameters to the request\n\n  extra_body: Add additional JSON properties to the request\n\n  timeout: Override the client-level default timeout for this request, in seconds"
                    },
                    "cancel": {
                        "signature": "(self, message_batch_id: str) -> BetaMessageBatch",
                        "docstring": "Batches may be canceled any time before processing ends.\n\nOnce cancellation is\ninitiated, the batch enters a `canceling` state, at which time the system may\ncomplete any in-progress, non-interruptible requests before finalizing\ncancellation.\n\nThe number of canceled requests is specified in `request_counts`. To determine\nwhich requests were canceled, check the individual results within the batch.\nNote that cancellation may not result in any canceled requests if they were\nnon-interruptible.\n\nArgs:\n  message_batch_id: ID of the Message Batch.\n\n  betas: Optional header to specify the beta version(s) you want to use.\n\n  extra_headers: Send extra headers\n\n  extra_query: Add additional query parameters to the request\n\n  extra_body: Add additional JSON properties to the request\n\n  timeout: Override the client-level default timeout for this request, in seconds"
                    },
                    "results": {
                        "signature": "(self, message_batch_id: str) -> JSONLDecoder[BetaMessageBatchIndividualResponse]",
                        "docstring": "Streams the results of a Message Batch as a `.jsonl` file.\n\nEach line in the file is a JSON object containing the result of a single request\nin the Message Batch. Results are not guaranteed to be in the same order as\nrequests. Use the `custom_id` field to match results to requests.\n\nArgs:\n  message_batch_id: ID of the Message Batch.\n\n  betas: Optional header to specify the beta version(s) you want to use.\n\n  extra_headers: Send extra headers\n\n  extra_query: Add additional query parameters to the request\n\n  extra_body: Add additional JSON properties to the request\n\n  timeout: Override the client-level default timeout for this request, in seconds"
                    }
                }
            },
            "AsyncBatches": {
                "methods": {
                    "with_raw_response": {
                        "signature": "(self) -> AsyncBatchesWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> AsyncBatchesWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    },
                    "create": {
                        "signature": "async (self) -> BetaMessageBatch",
                        "docstring": "Send a batch of Message creation requests.\n\nThe Message Batches API can be used to process multiple Messages API requests at\nonce. Once a Message Batch is created, it begins processing immediately. Batches\ncan take up to 24 hours to complete.\n\nArgs:\n  requests: List of requests for prompt completion. Each is an individual request to create\n      a Message.\n\n  betas: Optional header to specify the beta version(s) you want to use.\n\n  extra_headers: Send extra headers\n\n  extra_query: Add additional query parameters to the request\n\n  extra_body: Add additional JSON properties to the request\n\n  timeout: Override the client-level default timeout for this request, in seconds"
                    },
                    "retrieve": {
                        "signature": "async (self, message_batch_id: str) -> BetaMessageBatch",
                        "docstring": "This endpoint is idempotent and can be used to poll for Message Batch\ncompletion.\n\nTo access the results of a Message Batch, make a request to the\n`results_url` field in the response.\n\nArgs:\n  message_batch_id: ID of the Message Batch.\n\n  betas: Optional header to specify the beta version(s) you want to use.\n\n  extra_headers: Send extra headers\n\n  extra_query: Add additional query parameters to the request\n\n  extra_body: Add additional JSON properties to the request\n\n  timeout: Override the client-level default timeout for this request, in seconds"
                    },
                    "list": {
                        "signature": "(self) -> AsyncPaginator[BetaMessageBatch, AsyncPage[BetaMessageBatch]]",
                        "docstring": "List all Message Batches within a Workspace.\n\nMost recently created batches are\nreturned first.\n\nArgs:\n  after_id: ID of the object to use as a cursor for pagination. When provided, returns the\n      page of results immediately after this object.\n\n  before_id: ID of the object to use as a cursor for pagination. When provided, returns the\n      page of results immediately before this object.\n\n  limit: Number of items to return per page.\n\n      Defaults to `20`. Ranges from `1` to `100`.\n\n  betas: Optional header to specify the beta version(s) you want to use.\n\n  extra_headers: Send extra headers\n\n  extra_query: Add additional query parameters to the request\n\n  extra_body: Add additional JSON properties to the request\n\n  timeout: Override the client-level default timeout for this request, in seconds"
                    },
                    "cancel": {
                        "signature": "async (self, message_batch_id: str) -> BetaMessageBatch",
                        "docstring": "Batches may be canceled any time before processing ends.\n\nOnce cancellation is\ninitiated, the batch enters a `canceling` state, at which time the system may\ncomplete any in-progress, non-interruptible requests before finalizing\ncancellation.\n\nThe number of canceled requests is specified in `request_counts`. To determine\nwhich requests were canceled, check the individual results within the batch.\nNote that cancellation may not result in any canceled requests if they were\nnon-interruptible.\n\nArgs:\n  message_batch_id: ID of the Message Batch.\n\n  betas: Optional header to specify the beta version(s) you want to use.\n\n  extra_headers: Send extra headers\n\n  extra_query: Add additional query parameters to the request\n\n  extra_body: Add additional JSON properties to the request\n\n  timeout: Override the client-level default timeout for this request, in seconds"
                    },
                    "results": {
                        "signature": "async (self, message_batch_id: str) -> AsyncJSONLDecoder[BetaMessageBatchIndividualResponse]",
                        "docstring": "Streams the results of a Message Batch as a `.jsonl` file.\n\nEach line in the file is a JSON object containing the result of a single request\nin the Message Batch. Results are not guaranteed to be in the same order as\nrequests. Use the `custom_id` field to match results to requests.\n\nArgs:\n  message_batch_id: ID of the Message Batch.\n\n  betas: Optional header to specify the beta version(s) you want to use.\n\n  extra_headers: Send extra headers\n\n  extra_query: Add additional query parameters to the request\n\n  extra_body: Add additional JSON properties to the request\n\n  timeout: Override the client-level default timeout for this request, in seconds"
                    }
                }
            },
            "BatchesWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, batches: Batches) -> None"
                    }
                }
            },
            "AsyncBatchesWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, batches: AsyncBatches) -> None"
                    }
                }
            },
            "BatchesWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, batches: Batches) -> None"
                    }
                }
            },
            "AsyncBatchesWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, batches: AsyncBatches) -> None"
                    }
                }
            }
        }
    },
    "src\\anthropic\\resources\\beta\\messages\\messages.py": {
        "classes": {
            "Messages": {
                "methods": {
                    "batches": {
                        "signature": "(self) -> Batches"
                    },
                    "with_raw_response": {
                        "signature": "(self) -> MessagesWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> MessagesWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    },
                    "create": {
                        "signature": "(self) -> BetaMessage | Stream[BetaRawMessageStreamEvent]"
                    }
                }
            },
            "AsyncMessages": {
                "methods": {
                    "batches": {
                        "signature": "(self) -> AsyncBatches"
                    },
                    "with_raw_response": {
                        "signature": "(self) -> AsyncMessagesWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> AsyncMessagesWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    },
                    "create": {
                        "signature": "async (self) -> BetaMessage | AsyncStream[BetaRawMessageStreamEvent]"
                    }
                }
            },
            "MessagesWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: Messages) -> None"
                    },
                    "batches": {
                        "signature": "(self) -> BatchesWithRawResponse"
                    }
                }
            },
            "AsyncMessagesWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: AsyncMessages) -> None"
                    },
                    "batches": {
                        "signature": "(self) -> AsyncBatchesWithRawResponse"
                    }
                }
            },
            "MessagesWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: Messages) -> None"
                    },
                    "batches": {
                        "signature": "(self) -> BatchesWithStreamingResponse"
                    }
                }
            },
            "AsyncMessagesWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: AsyncMessages) -> None"
                    },
                    "batches": {
                        "signature": "(self) -> AsyncBatchesWithStreamingResponse"
                    }
                }
            }
        }
    },
    "src\\anthropic\\resources\\beta\\prompt_caching\\messages.py": {
        "classes": {
            "Messages": {
                "methods": {
                    "with_raw_response": {
                        "signature": "(self) -> MessagesWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> MessagesWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    },
                    "create": {
                        "signature": "(self) -> PromptCachingBetaMessage | Stream[RawPromptCachingBetaMessageStreamEvent]"
                    },
                    "stream": {
                        "signature": "(self) -> PromptCachingBetaMessageStreamManager",
                        "docstring": "Create a Message stream"
                    }
                }
            },
            "AsyncMessages": {
                "methods": {
                    "with_raw_response": {
                        "signature": "(self) -> AsyncMessagesWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> AsyncMessagesWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    },
                    "create": {
                        "signature": "async (self) -> PromptCachingBetaMessage | AsyncStream[RawPromptCachingBetaMessageStreamEvent]"
                    },
                    "stream": {
                        "signature": "(self) -> AsyncPromptCachingBetaMessageStreamManager",
                        "docstring": "Create a Message stream"
                    }
                }
            },
            "MessagesWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: Messages) -> None"
                    }
                }
            },
            "AsyncMessagesWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: AsyncMessages) -> None"
                    }
                }
            },
            "MessagesWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: Messages) -> None"
                    }
                }
            },
            "AsyncMessagesWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, messages: AsyncMessages) -> None"
                    }
                }
            }
        }
    },
    "src\\anthropic\\resources\\beta\\prompt_caching\\prompt_caching.py": {
        "classes": {
            "PromptCaching": {
                "methods": {
                    "messages": {
                        "signature": "(self) -> Messages"
                    },
                    "with_raw_response": {
                        "signature": "(self) -> PromptCachingWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> PromptCachingWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    }
                }
            },
            "AsyncPromptCaching": {
                "methods": {
                    "messages": {
                        "signature": "(self) -> AsyncMessages"
                    },
                    "with_raw_response": {
                        "signature": "(self) -> AsyncPromptCachingWithRawResponse",
                        "docstring": "This property can be used as a prefix for any HTTP method call to return the\nthe raw response object instead of the parsed content.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#accessing-raw-response-data-eg-headers"
                    },
                    "with_streaming_response": {
                        "signature": "(self) -> AsyncPromptCachingWithStreamingResponse",
                        "docstring": "An alternative to `.with_raw_response` that doesn't eagerly read the response body.\n\nFor more information, see https://www.github.com/anthropics/anthropic-sdk-python#with_streaming_response"
                    }
                }
            },
            "PromptCachingWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, prompt_caching: PromptCaching) -> None"
                    },
                    "messages": {
                        "signature": "(self) -> MessagesWithRawResponse"
                    }
                }
            },
            "AsyncPromptCachingWithRawResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, prompt_caching: AsyncPromptCaching) -> None"
                    },
                    "messages": {
                        "signature": "(self) -> AsyncMessagesWithRawResponse"
                    }
                }
            },
            "PromptCachingWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, prompt_caching: PromptCaching) -> None"
                    },
                    "messages": {
                        "signature": "(self) -> MessagesWithStreamingResponse"
                    }
                }
            },
            "AsyncPromptCachingWithStreamingResponse": {
                "methods": {
                    "__init__": {
                        "signature": "(self, prompt_caching: AsyncPromptCaching) -> None"
                    },
                    "messages": {
                        "signature": "(self) -> AsyncMessagesWithStreamingResponse"
                    }
                }
            }
        }
    },
    "src\\anthropic\\types\\beta_api_error.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta_authentication_error.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta_error_response.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta_invalid_request_error.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta_not_found_error.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta_overloaded_error.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta_permission_error.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta_rate_limit_error.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\completion.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\completion_create_params.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\image_block_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\input_json_delta.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\message.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\message_create_params.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\message_delta_usage.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\message_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\metadata_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\raw_content_block_delta_event.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\raw_content_block_start_event.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\raw_content_block_stop_event.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\raw_message_delta_event.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\raw_message_start_event.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\raw_message_stop_event.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\text_block.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\text_block_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\text_delta.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\tool_choice_any_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\tool_choice_auto_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\tool_choice_tool_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\tool_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\tool_result_block_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\tool_use_block.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\tool_use_block_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\usage.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_cache_control_ephemeral_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_image_block_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_input_json_delta.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_message.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_message_delta_usage.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_message_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_metadata_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_raw_content_block_delta_event.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_raw_content_block_start_event.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_raw_content_block_stop_event.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_raw_message_delta_event.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_raw_message_start_event.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_raw_message_stop_event.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_text_block.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_text_block_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_text_delta.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_tool_bash_20241022_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_tool_choice_any_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_tool_choice_auto_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_tool_choice_tool_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_tool_computer_use_20241022_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_tool_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_tool_result_block_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_tool_text_editor_20241022_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_tool_use_block.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_tool_use_block_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\beta_usage.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\message_create_params.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\messages\\batch_create_params.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\messages\\batch_list_params.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\messages\\beta_message_batch.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\messages\\beta_message_batch_canceled_result.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\messages\\beta_message_batch_errored_result.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\messages\\beta_message_batch_expired_result.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\messages\\beta_message_batch_individual_response.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\messages\\beta_message_batch_request_counts.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\messages\\beta_message_batch_succeeded_result.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\prompt_caching\\message_create_params.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\prompt_caching\\prompt_caching_beta_cache_control_ephemeral_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\prompt_caching\\prompt_caching_beta_image_block_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\prompt_caching\\prompt_caching_beta_message.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\prompt_caching\\prompt_caching_beta_message_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\prompt_caching\\prompt_caching_beta_text_block_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\prompt_caching\\prompt_caching_beta_tool_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\prompt_caching\\prompt_caching_beta_tool_result_block_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\prompt_caching\\prompt_caching_beta_tool_use_block_param.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\prompt_caching\\prompt_caching_beta_usage.py": {
        "classes": {}
    },
    "src\\anthropic\\types\\beta\\prompt_caching\\raw_prompt_caching_beta_message_start_event.py": {
        "classes": {}
    },
    "src\\anthropic\\_decoders\\jsonl.py": {
        "classes": {
            "JSONLDecoder": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "__decode__": {
                        "signature": "(self) -> Iterator[_T]"
                    },
                    "__next__": {
                        "signature": "(self) -> _T"
                    },
                    "__iter__": {
                        "signature": "(self) -> Iterator[_T]"
                    }
                },
                "docstring": "A decoder for [JSON Lines](https://jsonlines.org) format.\n\nThis class provides an iterator over a byte-iterator that parses each JSON Line\ninto a given type."
            },
            "AsyncJSONLDecoder": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "__decode__": {
                        "signature": "async (self) -> AsyncIterator[_T]"
                    },
                    "__anext__": {
                        "signature": "async (self) -> _T"
                    },
                    "__aiter__": {
                        "signature": "async (self) -> AsyncIterator[_T]"
                    }
                },
                "docstring": "A decoder for [JSON Lines](https://jsonlines.org) format.\n\nThis class provides an async iterator over a byte-iterator that parses each JSON Line\ninto a given type."
            }
        }
    },
    "src\\anthropic\\_utils\\_logs.py": {
        "functions": {
            "_basic_config": {
                "signature": "() -> None"
            },
            "setup_logging": {
                "signature": "() -> None"
            }
        }
    },
    "src\\anthropic\\_utils\\_proxy.py": {
        "classes": {
            "LazyProxy": {
                "methods": {
                    "__getattr__": {
                        "signature": "(self, attr: str) -> object"
                    },
                    "__repr__": {
                        "signature": "(self) -> str"
                    },
                    "__str__": {
                        "signature": "(self) -> str"
                    },
                    "__dir__": {
                        "signature": "(self) -> Iterable[str]"
                    },
                    "__class__": {
                        "signature": "(self) -> type"
                    },
                    "__get_proxied__": {
                        "signature": "(self) -> T"
                    },
                    "__as_proxied__": {
                        "signature": "(self) -> T",
                        "docstring": "Helper method that returns the current proxy, typed as the loaded object"
                    },
                    "__load__": {
                        "signature": "(self) -> T"
                    }
                },
                "docstring": "Implements data methods to pretend that an instance is another instance.\n\nThis includes forwarding attribute access and other methods."
            }
        }
    },
    "src\\anthropic\\_utils\\_reflection.py": {
        "functions": {
            "function_has_argument": {
                "signature": "(func: Callable[..., Any], arg_name: str) -> bool",
                "docstring": "Returns whether or not the given function has a specific parameter"
            },
            "assert_signatures_in_sync": {
                "signature": "(source_func: Callable[..., Any], check_func: Callable[..., Any]) -> None",
                "docstring": "Ensure that the signature of the second function matches the first."
            }
        }
    },
    "src\\anthropic\\_utils\\_streams.py": {
        "functions": {
            "consume_sync_iterator": {
                "signature": "(iterator: Iterator[Any]) -> None"
            },
            "consume_async_iterator": {
                "signature": "async (iterator: AsyncIterator[Any]) -> None"
            }
        }
    },
    "src\\anthropic\\_utils\\_sync.py": {
        "functions": {
            "asyncify": {
                "signature": "(function: Callable[T_ParamSpec, T_Retval]) -> Callable[T_ParamSpec, Awaitable[T_Retval]]",
                "docstring": "Take a blocking function and create an async one that receives the same\npositional and keyword arguments, and that when called, calls the original function\nin a worker thread using `anyio.to_thread.run_sync()`. Internally,\n`asyncer.asyncify()` uses the same `anyio.to_thread.run_sync()`, but it supports\nkeyword arguments additional to positional arguments and it adds better support for\nautocompletion and inline errors for the arguments of the function called and the\nreturn value.\n\nIf the `cancellable` option is enabled and the task waiting for its completion is\ncancelled, the thread will still run its course but its return value (or any raised\nexception) will be ignored.\n\nUse it like this:\n\n```Python\ndef do_work(arg1, arg2, kwarg1=\"\", kwarg2=\"\") -> str:\n    # Do work\n    return \"Some result\"\n\n\nresult = await to_thread.asyncify(do_work)(\"spam\", \"ham\", kwarg1=\"a\", kwarg2=\"b\")\nprint(result)\n```\n\n## Arguments\n\n`function`: a blocking regular callable (e.g. a function)\n`cancellable`: `True` to allow cancellation of the operation\n`limiter`: capacity limiter to use to limit the total amount of threads running\n    (if omitted, the default limiter is used)\n\n## Return\n\nAn async function that takes the same positional and keyword arguments as the\noriginal one, that when called runs the same original function in a thread worker\nand returns the result."
            }
        }
    },
    "src\\anthropic\\_utils\\_transform.py": {
        "functions": {
            "maybe_transform": {
                "signature": "(data: object, expected_type: object) -> Any | None",
                "docstring": "Wrapper over `transform()` that allows `None` to be passed.\n\nSee `transform()` for more details."
            },
            "transform": {
                "signature": "(data: _T, expected_type: object) -> _T",
                "docstring": "Transform dictionaries based off of type information from the given type, for example:\n\n```py\nclass Params(TypedDict, total=False):\n    card_id: Required[Annotated[str, PropertyInfo(alias=\"cardID\")]]\n\n\ntransformed = transform({\"card_id\": \"<my card ID>\"}, Params)\n# {'cardID': '<my card ID>'}\n```\n\nAny keys / data that does not have type information given will be included as is.\n\nIt should be noted that the transformations that this function does are not represented in the type system."
            },
            "_get_annotated_type": {
                "signature": "(type_: type) -> type | None",
                "docstring": "If the given type is an `Annotated` type then it is returned, if not `None` is returned.\n\nThis also unwraps the type when applicable, e.g. `Required[Annotated[T, ...]]`"
            },
            "_maybe_transform_key": {
                "signature": "(key: str, type_: type) -> str",
                "docstring": "Transform the given `data` based on the annotations provided in `type_`.\n\nNote: this function only looks at `Annotated` types that contain `PropertInfo` metadata."
            },
            "_transform_recursive": {
                "signature": "(data: object) -> object",
                "docstring": "Transform the given data against the expected type.\n\nArgs:\n    annotation: The direct type annotation given to the particular piece of data.\n        This may or may not be wrapped in metadata types, e.g. `Required[T]`, `Annotated[T, ...]` etc\n\n    inner_type: If applicable, this is the \"inside\" type. This is useful in certain cases where the outside type\n        is a container type such as `List[T]`. In that case `inner_type` should be set to `T` so that each entry in\n        the list can be transformed using the metadata from the container type.\n\n        Defaults to the same value as the `annotation` argument."
            },
            "_format_data": {
                "signature": "(data: object, format_: PropertyFormat, format_template: str | None) -> object"
            },
            "_transform_typeddict": {
                "signature": "(data: Mapping[str, object], expected_type: type) -> Mapping[str, object]"
            },
            "async_maybe_transform": {
                "signature": "async (data: object, expected_type: object) -> Any | None",
                "docstring": "Wrapper over `async_transform()` that allows `None` to be passed.\n\nSee `async_transform()` for more details."
            },
            "async_transform": {
                "signature": "async (data: _T, expected_type: object) -> _T",
                "docstring": "Transform dictionaries based off of type information from the given type, for example:\n\n```py\nclass Params(TypedDict, total=False):\n    card_id: Required[Annotated[str, PropertyInfo(alias=\"cardID\")]]\n\n\ntransformed = transform({\"card_id\": \"<my card ID>\"}, Params)\n# {'cardID': '<my card ID>'}\n```\n\nAny keys / data that does not have type information given will be included as is.\n\nIt should be noted that the transformations that this function does are not represented in the type system."
            },
            "_async_transform_recursive": {
                "signature": "async (data: object) -> object",
                "docstring": "Transform the given data against the expected type.\n\nArgs:\n    annotation: The direct type annotation given to the particular piece of data.\n        This may or may not be wrapped in metadata types, e.g. `Required[T]`, `Annotated[T, ...]` etc\n\n    inner_type: If applicable, this is the \"inside\" type. This is useful in certain cases where the outside type\n        is a container type such as `List[T]`. In that case `inner_type` should be set to `T` so that each entry in\n        the list can be transformed using the metadata from the container type.\n\n        Defaults to the same value as the `annotation` argument."
            },
            "_async_format_data": {
                "signature": "async (data: object, format_: PropertyFormat, format_template: str | None) -> object"
            },
            "_async_transform_typeddict": {
                "signature": "async (data: Mapping[str, object], expected_type: type) -> Mapping[str, object]"
            }
        },
        "classes": {
            "PropertyInfo": {
                "methods": {
                    "__init__": {
                        "signature": "(self) -> None"
                    },
                    "__repr__": {
                        "signature": "(self) -> str"
                    }
                },
                "docstring": "Metadata class to be used in Annotated types to provide information about a given type.\n\nFor example:\n\nclass MyParams(TypedDict):\n    account_holder_name: Annotated[str, PropertyInfo(alias='accountHolderName')]\n\nThis means that {'account_holder_name': 'Robert'} will be transformed to {'accountHolderName': 'Robert'} before being sent to the API."
            }
        }
    },
    "src\\anthropic\\_utils\\_typing.py": {
        "functions": {
            "is_annotated_type": {
                "signature": "(typ: type) -> bool"
            },
            "is_list_type": {
                "signature": "(typ: type) -> bool"
            },
            "is_iterable_type": {
                "signature": "(typ: type) -> bool",
                "docstring": "If the given type is `typing.Iterable[T]`"
            },
            "is_union_type": {
                "signature": "(typ: type) -> bool"
            },
            "is_required_type": {
                "signature": "(typ: type) -> bool"
            },
            "is_typevar": {
                "signature": "(typ: type) -> bool"
            },
            "strip_annotated_type": {
                "signature": "(typ: type) -> type"
            },
            "extract_type_arg": {
                "signature": "(typ: type, index: int) -> type"
            },
            "extract_type_var_from_base": {
                "signature": "(typ: type) -> type",
                "docstring": "Given a type like `Foo[T]`, returns the generic type variable `T`.\n\nThis also handles the case where a concrete subclass is given, e.g.\n```py\nclass MyResponse(Foo[bytes]):\n    ...\n\nextract_type_var(MyResponse, bases=(Foo,), index=0) -> bytes\n```\n\nAnd where a generic subclass is given:\n```py\n_T = TypeVar('_T')\nclass MyResponse(Foo[_T]):\n    ...\n\nextract_type_var(MyResponse[bytes], bases=(Foo,), index=0) -> bytes\n```"
            }
        }
    },
    "src\\anthropic\\_utils\\_utils.py": {
        "functions": {
            "flatten": {
                "signature": "(t: Iterable[Iterable[_T]]) -> list[_T]"
            },
            "extract_files": {
                "signature": "(query: Mapping[str, object]) -> list[tuple[str, FileTypes]]",
                "docstring": "Recursively extract files from the given dictionary based on specified paths.\n\nA path may look like this ['foo', 'files', '<array>', 'data'].\n\nNote: this mutates the given dictionary."
            },
            "_extract_items": {
                "signature": "(obj: object, path: Sequence[str]) -> list[tuple[str, FileTypes]]"
            },
            "is_given": {
                "signature": "(obj: NotGivenOr[_T]) -> TypeGuard[_T]"
            },
            "is_tuple": {
                "signature": "(obj: object) -> TypeGuard[tuple[object, ...]]"
            },
            "is_tuple_t": {
                "signature": "(obj: _TupleT | object) -> TypeGuard[_TupleT]"
            },
            "is_sequence": {
                "signature": "(obj: object) -> TypeGuard[Sequence[object]]"
            },
            "is_sequence_t": {
                "signature": "(obj: _SequenceT | object) -> TypeGuard[_SequenceT]"
            },
            "is_mapping": {
                "signature": "(obj: object) -> TypeGuard[Mapping[str, object]]"
            },
            "is_mapping_t": {
                "signature": "(obj: _MappingT | object) -> TypeGuard[_MappingT]"
            },
            "is_dict": {
                "signature": "(obj: object) -> TypeGuard[dict[object, object]]"
            },
            "is_list": {
                "signature": "(obj: object) -> TypeGuard[list[object]]"
            },
            "is_iterable": {
                "signature": "(obj: object) -> TypeGuard[Iterable[object]]"
            },
            "deepcopy_minimal": {
                "signature": "(item: _T) -> _T",
                "docstring": "Minimal reimplementation of copy.deepcopy() that will only copy certain object types:\n\n- mappings, e.g. `dict`\n- list\n\nThis is done for performance reasons."
            },
            "human_join": {
                "signature": "(seq: Sequence[str]) -> str"
            },
            "quote": {
                "signature": "(string: str) -> str",
                "docstring": "Add single quotation marks around the given string. Does *not* do any escaping."
            },
            "required_args": {
                "signature": "(*variants: Sequence[str]) -> Callable[[CallableT], CallableT]",
                "docstring": "Decorator to enforce a given set of arguments or variants of arguments are passed to the decorated function.\n\nUseful for enforcing runtime validation of overloaded functions.\n\nExample usage:\n```py\n@overload\ndef foo(*, a: str) -> str: ...\n\n\n@overload\ndef foo(*, b: bool) -> str: ...\n\n\n# This enforces the same constraints that a static type checker would\n# i.e. that either a or b must be passed to the function\n@required_args([\"a\"], [\"b\"])\ndef foo(*, a: str | None = None, b: bool | None = None) -> str: ...\n```"
            },
            "strip_not_given": {
                "signature": "(obj: object | None) -> object",
                "docstring": "Remove all top-level keys where their values are instances of `NotGiven`"
            },
            "coerce_integer": {
                "signature": "(val: str) -> int"
            },
            "coerce_float": {
                "signature": "(val: str) -> float"
            },
            "coerce_boolean": {
                "signature": "(val: str) -> bool"
            },
            "maybe_coerce_integer": {
                "signature": "(val: str | None) -> int | None"
            },
            "maybe_coerce_float": {
                "signature": "(val: str | None) -> float | None"
            },
            "maybe_coerce_boolean": {
                "signature": "(val: str | None) -> bool | None"
            },
            "removeprefix": {
                "signature": "(string: str, prefix: str) -> str",
                "docstring": "Remove a prefix from a string.\n\nBackport of `str.removeprefix` for Python < 3.9"
            },
            "removesuffix": {
                "signature": "(string: str, suffix: str) -> str",
                "docstring": "Remove a suffix from a string.\n\nBackport of `str.removesuffix` for Python < 3.9"
            },
            "file_from_path": {
                "signature": "(path: str) -> FileTypes"
            },
            "get_required_header": {
                "signature": "(headers: HeadersLike, header: str) -> str"
            },
            "get_async_library": {
                "signature": "() -> str"
            },
            "lru_cache": {
                "signature": "() -> Callable[[CallableT], CallableT]",
                "docstring": "A version of functools.lru_cache that retains the type signature\nfor the wrapped function arguments."
            }
        }
    },
    "tests\\conftest.py": {
        "functions": {
            "event_loop": {
                "signature": "() -> Iterator[asyncio.AbstractEventLoop]"
            },
            "client": {
                "signature": "(request: FixtureRequest) -> Iterator[Anthropic]"
            },
            "async_client": {
                "signature": "async (request: FixtureRequest) -> AsyncIterator[AsyncAnthropic]"
            }
        }
    },
    "tests\\test_client.py": {
        "functions": {
            "_get_params": {
                "signature": "(client: BaseClient[Any, Any]) -> dict[str, str]"
            },
            "_low_retry_timeout": {
                "signature": "(*_args: Any, **_kwargs: Any) -> float"
            },
            "_get_open_connections": {
                "signature": "(client: Anthropic | AsyncAnthropic) -> int"
            }
        },
        "classes": {
            "TestAnthropic": {
                "methods": {
                    "test_raw_response": {
                        "signature": "(self, respx_mock: MockRouter) -> None"
                    },
                    "test_raw_response_for_binary": {
                        "signature": "(self, respx_mock: MockRouter) -> None"
                    },
                    "test_copy": {
                        "signature": "(self) -> None"
                    },
                    "test_copy_default_options": {
                        "signature": "(self) -> None"
                    },
                    "test_copy_default_headers": {
                        "signature": "(self) -> None"
                    },
                    "test_copy_default_query": {
                        "signature": "(self) -> None"
                    },
                    "test_copy_signature": {
                        "signature": "(self) -> None"
                    },
                    "test_copy_build_request": {
                        "signature": "(self) -> None"
                    },
                    "test_request_timeout": {
                        "signature": "(self) -> None"
                    },
                    "test_client_timeout_option": {
                        "signature": "(self) -> None"
                    },
                    "test_http_client_timeout_option": {
                        "signature": "(self) -> None"
                    },
                    "test_invalid_http_client": {
                        "signature": "async (self) -> None"
                    },
                    "test_default_headers_option": {
                        "signature": "(self) -> None"
                    },
                    "test_validate_headers": {
                        "signature": "(self) -> None"
                    },
                    "test_default_query_option": {
                        "signature": "(self) -> None"
                    },
                    "test_request_extra_json": {
                        "signature": "(self) -> None"
                    },
                    "test_request_extra_headers": {
                        "signature": "(self) -> None"
                    },
                    "test_request_extra_query": {
                        "signature": "(self) -> None"
                    },
                    "test_multipart_repeating_array": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_basic_union_response": {
                        "signature": "(self, respx_mock: MockRouter) -> None"
                    },
                    "test_union_response_different_types": {
                        "signature": "(self, respx_mock: MockRouter) -> None",
                        "docstring": "Union of objects with the same field name using a different type"
                    },
                    "test_non_application_json_content_type_for_json_data": {
                        "signature": "(self, respx_mock: MockRouter) -> None",
                        "docstring": "Response that sets Content-Type to something other than application/json but returns json data"
                    },
                    "test_base_url_setter": {
                        "signature": "(self) -> None"
                    },
                    "test_base_url_env": {
                        "signature": "(self) -> None"
                    },
                    "test_base_url_trailing_slash": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_base_url_no_trailing_slash": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_absolute_request_url": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_transport_option_is_deprecated": {
                        "signature": "(self) -> None"
                    },
                    "test_transport_option_mutually_exclusive_with_http_client": {
                        "signature": "(self) -> None"
                    },
                    "test_connection_pool_limits_option_is_deprecated": {
                        "signature": "(self) -> None"
                    },
                    "test_connection_pool_limits_option_mutually_exclusive_with_http_client": {
                        "signature": "(self) -> None"
                    },
                    "test_proxies_option_is_deprecated": {
                        "signature": "(self) -> None"
                    },
                    "test_proxies_option_mutually_exclusive_with_http_client": {
                        "signature": "(self) -> None"
                    },
                    "test_copied_client_does_not_close_http": {
                        "signature": "(self) -> None"
                    },
                    "test_client_context_manager": {
                        "signature": "(self) -> None"
                    },
                    "test_client_response_validation_error": {
                        "signature": "(self, respx_mock: MockRouter) -> None"
                    },
                    "test_client_max_retries_validation": {
                        "signature": "(self) -> None"
                    },
                    "test_default_stream_cls": {
                        "signature": "(self, respx_mock: MockRouter) -> None"
                    },
                    "test_received_text_for_expected_json": {
                        "signature": "(self, respx_mock: MockRouter) -> None"
                    },
                    "test_parse_retry_after_header": {
                        "signature": "(self, remaining_retries: int, retry_after: str, timeout: float) -> None"
                    },
                    "test_retrying_timeout_errors_doesnt_leak": {
                        "signature": "(self, respx_mock: MockRouter) -> None"
                    },
                    "test_retrying_status_errors_doesnt_leak": {
                        "signature": "(self, respx_mock: MockRouter) -> None"
                    },
                    "test_retries_taken": {
                        "signature": "(self, client: Anthropic, failures_before_success: int, failure_mode: Literal['status', 'exception'], respx_mock: MockRouter) -> None"
                    },
                    "test_omit_retry_count_header": {
                        "signature": "(self, client: Anthropic, failures_before_success: int, respx_mock: MockRouter) -> None"
                    },
                    "test_overwrite_retry_count_header": {
                        "signature": "(self, client: Anthropic, failures_before_success: int, respx_mock: MockRouter) -> None"
                    },
                    "test_retries_taken_new_response_class": {
                        "signature": "(self, client: Anthropic, failures_before_success: int, respx_mock: MockRouter) -> None"
                    }
                }
            },
            "TestAsyncAnthropic": {
                "methods": {
                    "test_raw_response": {
                        "signature": "async (self, respx_mock: MockRouter) -> None"
                    },
                    "test_raw_response_for_binary": {
                        "signature": "async (self, respx_mock: MockRouter) -> None"
                    },
                    "test_copy": {
                        "signature": "(self) -> None"
                    },
                    "test_copy_default_options": {
                        "signature": "(self) -> None"
                    },
                    "test_copy_default_headers": {
                        "signature": "(self) -> None"
                    },
                    "test_copy_default_query": {
                        "signature": "(self) -> None"
                    },
                    "test_copy_signature": {
                        "signature": "(self) -> None"
                    },
                    "test_copy_build_request": {
                        "signature": "(self) -> None"
                    },
                    "test_request_timeout": {
                        "signature": "async (self) -> None"
                    },
                    "test_client_timeout_option": {
                        "signature": "async (self) -> None"
                    },
                    "test_http_client_timeout_option": {
                        "signature": "async (self) -> None"
                    },
                    "test_invalid_http_client": {
                        "signature": "(self) -> None"
                    },
                    "test_default_headers_option": {
                        "signature": "(self) -> None"
                    },
                    "test_validate_headers": {
                        "signature": "(self) -> None"
                    },
                    "test_default_query_option": {
                        "signature": "(self) -> None"
                    },
                    "test_request_extra_json": {
                        "signature": "(self) -> None"
                    },
                    "test_request_extra_headers": {
                        "signature": "(self) -> None"
                    },
                    "test_request_extra_query": {
                        "signature": "(self) -> None"
                    },
                    "test_multipart_repeating_array": {
                        "signature": "(self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_basic_union_response": {
                        "signature": "async (self, respx_mock: MockRouter) -> None"
                    },
                    "test_union_response_different_types": {
                        "signature": "async (self, respx_mock: MockRouter) -> None",
                        "docstring": "Union of objects with the same field name using a different type"
                    },
                    "test_non_application_json_content_type_for_json_data": {
                        "signature": "async (self, respx_mock: MockRouter) -> None",
                        "docstring": "Response that sets Content-Type to something other than application/json but returns json data"
                    },
                    "test_base_url_setter": {
                        "signature": "(self) -> None"
                    },
                    "test_base_url_env": {
                        "signature": "(self) -> None"
                    },
                    "test_base_url_trailing_slash": {
                        "signature": "(self, client: AsyncAnthropic) -> None"
                    },
                    "test_base_url_no_trailing_slash": {
                        "signature": "(self, client: AsyncAnthropic) -> None"
                    },
                    "test_absolute_request_url": {
                        "signature": "(self, client: AsyncAnthropic) -> None"
                    },
                    "test_transport_option_is_deprecated": {
                        "signature": "(self) -> None"
                    },
                    "test_transport_option_mutually_exclusive_with_http_client": {
                        "signature": "async (self) -> None"
                    },
                    "test_connection_pool_limits_option_is_deprecated": {
                        "signature": "(self) -> None"
                    },
                    "test_connection_pool_limits_option_mutually_exclusive_with_http_client": {
                        "signature": "async (self) -> None"
                    },
                    "test_proxies_option_is_deprecated": {
                        "signature": "(self) -> None"
                    },
                    "test_proxies_option_mutually_exclusive_with_http_client": {
                        "signature": "async (self) -> None"
                    },
                    "test_copied_client_does_not_close_http": {
                        "signature": "async (self) -> None"
                    },
                    "test_client_context_manager": {
                        "signature": "async (self) -> None"
                    },
                    "test_client_response_validation_error": {
                        "signature": "async (self, respx_mock: MockRouter) -> None"
                    },
                    "test_client_max_retries_validation": {
                        "signature": "async (self) -> None"
                    },
                    "test_default_stream_cls": {
                        "signature": "async (self, respx_mock: MockRouter) -> None"
                    },
                    "test_received_text_for_expected_json": {
                        "signature": "async (self, respx_mock: MockRouter) -> None"
                    },
                    "test_parse_retry_after_header": {
                        "signature": "async (self, remaining_retries: int, retry_after: str, timeout: float) -> None"
                    },
                    "test_retrying_timeout_errors_doesnt_leak": {
                        "signature": "async (self, respx_mock: MockRouter) -> None"
                    },
                    "test_retrying_status_errors_doesnt_leak": {
                        "signature": "async (self, respx_mock: MockRouter) -> None"
                    },
                    "test_retries_taken": {
                        "signature": "async (self, async_client: AsyncAnthropic, failures_before_success: int, failure_mode: Literal['status', 'exception'], respx_mock: MockRouter) -> None"
                    },
                    "test_omit_retry_count_header": {
                        "signature": "async (self, async_client: AsyncAnthropic, failures_before_success: int, respx_mock: MockRouter) -> None"
                    },
                    "test_overwrite_retry_count_header": {
                        "signature": "async (self, async_client: AsyncAnthropic, failures_before_success: int, respx_mock: MockRouter) -> None"
                    },
                    "test_retries_taken_new_response_class": {
                        "signature": "async (self, async_client: AsyncAnthropic, failures_before_success: int, respx_mock: MockRouter) -> None"
                    }
                }
            }
        }
    },
    "tests\\test_deepcopy.py": {
        "functions": {
            "assert_different_identities": {
                "signature": "(obj1: object, obj2: object) -> None"
            },
            "test_simple_dict": {
                "signature": "() -> None"
            },
            "test_nested_dict": {
                "signature": "() -> None"
            },
            "test_complex_nested_dict": {
                "signature": "() -> None"
            },
            "test_simple_list": {
                "signature": "() -> None"
            },
            "test_nested_list": {
                "signature": "() -> None"
            },
            "test_ignores_other_types": {
                "signature": "() -> None"
            }
        },
        "classes": {}
    },
    "tests\\test_extract_files.py": {
        "functions": {
            "test_removes_files_from_input": {
                "signature": "() -> None"
            },
            "test_multiple_files": {
                "signature": "() -> None"
            },
            "test_ignores_incorrect_paths": {
                "signature": "(query: dict[str, object], paths: Sequence[Sequence[str]], expected: list[tuple[str, FileTypes]]) -> None"
            }
        }
    },
    "tests\\test_files.py": {
        "functions": {
            "test_pathlib_includes_file_name": {
                "signature": "() -> None"
            },
            "test_tuple_input": {
                "signature": "() -> None"
            },
            "test_async_pathlib_includes_file_name": {
                "signature": "async () -> None"
            },
            "test_async_supports_anyio_path": {
                "signature": "async () -> None"
            },
            "test_async_tuple_input": {
                "signature": "async () -> None"
            },
            "test_string_not_allowed": {
                "signature": "() -> None"
            }
        }
    },
    "tests\\test_legacy_response.py": {
        "functions": {
            "test_response_parse_mismatched_basemodel": {
                "signature": "(client: Anthropic) -> None"
            },
            "test_response_parse_bool": {
                "signature": "(client: Anthropic, content: str, expected: bool) -> None"
            },
            "test_response_parse_custom_stream": {
                "signature": "(client: Anthropic) -> None"
            },
            "test_response_parse_custom_model": {
                "signature": "(client: Anthropic) -> None"
            },
            "test_response_parse_annotated_type": {
                "signature": "(client: Anthropic) -> None"
            },
            "test_response_parse_expect_model_union_non_json_content": {
                "signature": "(client: Anthropic) -> None"
            }
        },
        "classes": {}
    },
    "tests\\test_models.py": {
        "functions": {
            "test_basic": {
                "signature": "(value: object) -> None"
            },
            "test_directly_nested_model": {
                "signature": "() -> None"
            },
            "test_optional_nested_model": {
                "signature": "() -> None"
            },
            "test_list_nested_model": {
                "signature": "() -> None"
            },
            "test_optional_list_nested_model": {
                "signature": "() -> None"
            },
            "test_list_optional_items_nested_model": {
                "signature": "() -> None"
            },
            "test_list_mismatched_type": {
                "signature": "() -> None"
            },
            "test_raw_dictionary": {
                "signature": "() -> None"
            },
            "test_nested_dictionary_model": {
                "signature": "() -> None"
            },
            "test_unknown_fields": {
                "signature": "() -> None"
            },
            "test_strict_validation_unknown_fields": {
                "signature": "() -> None"
            },
            "test_aliases": {
                "signature": "() -> None"
            },
            "test_repr": {
                "signature": "() -> None"
            },
            "test_repr_nested_model": {
                "signature": "() -> None"
            },
            "test_optional_list": {
                "signature": "() -> None"
            },
            "test_nested_union_of_models": {
                "signature": "() -> None"
            },
            "test_nested_union_of_mixed_types": {
                "signature": "() -> None"
            },
            "test_nested_union_multiple_variants": {
                "signature": "() -> None"
            },
            "test_nested_union_invalid_data": {
                "signature": "() -> None"
            },
            "test_list_of_unions": {
                "signature": "() -> None"
            },
            "test_union_of_lists": {
                "signature": "() -> None"
            },
            "test_dict_of_union": {
                "signature": "() -> None"
            },
            "test_double_nested_union": {
                "signature": "() -> None"
            },
            "test_union_of_dict": {
                "signature": "() -> None"
            },
            "test_iso8601_datetime": {
                "signature": "() -> None"
            },
            "test_does_not_coerce_int": {
                "signature": "() -> None"
            },
            "test_int_to_float_safe_conversion": {
                "signature": "() -> None"
            },
            "test_deprecated_alias": {
                "signature": "() -> None"
            },
            "test_omitted_fields": {
                "signature": "() -> None"
            },
            "test_to_dict": {
                "signature": "() -> None"
            },
            "test_forwards_compat_model_dump_method": {
                "signature": "() -> None"
            },
            "test_to_json": {
                "signature": "() -> None"
            },
            "test_forwards_compat_model_dump_json_method": {
                "signature": "() -> None"
            },
            "test_type_compat": {
                "signature": "() -> None"
            },
            "test_annotated_types": {
                "signature": "() -> None"
            },
            "test_discriminated_unions_invalid_data": {
                "signature": "() -> None"
            },
            "test_discriminated_unions_unknown_variant": {
                "signature": "() -> None"
            },
            "test_discriminated_unions_invalid_data_nested_unions": {
                "signature": "() -> None"
            },
            "test_discriminated_unions_with_aliases_invalid_data": {
                "signature": "() -> None"
            },
            "test_discriminated_unions_overlapping_discriminators_invalid_data": {
                "signature": "() -> None"
            },
            "test_discriminated_unions_invalid_data_uses_cache": {
                "signature": "() -> None"
            }
        },
        "classes": {}
    },
    "tests\\test_qs.py": {
        "functions": {
            "test_empty": {
                "signature": "() -> None"
            },
            "test_basic": {
                "signature": "() -> None"
            },
            "test_nested_dotted": {
                "signature": "(method: str) -> None"
            },
            "test_nested_brackets": {
                "signature": "() -> None"
            },
            "test_array_comma": {
                "signature": "(method: str) -> None"
            },
            "test_array_repeat": {
                "signature": "() -> None"
            },
            "test_array_brackets": {
                "signature": "(method: str) -> None"
            },
            "test_unknown_array_format": {
                "signature": "() -> None"
            }
        }
    },
    "tests\\test_required_args.py": {
        "functions": {
            "test_too_many_positional_params": {
                "signature": "() -> None"
            },
            "test_positional_param": {
                "signature": "() -> None"
            },
            "test_keyword_only_param": {
                "signature": "() -> None"
            },
            "test_multiple_params": {
                "signature": "() -> None"
            },
            "test_multiple_variants": {
                "signature": "() -> None"
            },
            "test_multiple_params_multiple_variants": {
                "signature": "() -> None"
            }
        }
    },
    "tests\\test_response.py": {
        "functions": {
            "test_extract_response_type_direct_classes": {
                "signature": "() -> None"
            },
            "test_extract_response_type_direct_class_missing_type_arg": {
                "signature": "() -> None"
            },
            "test_extract_response_type_concrete_subclasses": {
                "signature": "() -> None"
            },
            "test_extract_response_type_binary_response": {
                "signature": "() -> None"
            },
            "test_response_parse_mismatched_basemodel": {
                "signature": "(client: Anthropic) -> None"
            },
            "test_async_response_parse_mismatched_basemodel": {
                "signature": "async (async_client: AsyncAnthropic) -> None"
            },
            "test_response_parse_custom_stream": {
                "signature": "(client: Anthropic) -> None"
            },
            "test_async_response_parse_custom_stream": {
                "signature": "async (async_client: AsyncAnthropic) -> None"
            },
            "test_response_parse_custom_model": {
                "signature": "(client: Anthropic) -> None"
            },
            "test_async_response_parse_custom_model": {
                "signature": "async (async_client: AsyncAnthropic) -> None"
            },
            "test_response_parse_annotated_type": {
                "signature": "(client: Anthropic) -> None"
            },
            "test_async_response_parse_annotated_type": {
                "signature": "async (async_client: AsyncAnthropic) -> None"
            },
            "test_response_parse_bool": {
                "signature": "(client: Anthropic, content: str, expected: bool) -> None"
            },
            "test_async_response_parse_bool": {
                "signature": "async (client: AsyncAnthropic, content: str, expected: bool) -> None"
            },
            "test_response_parse_expect_model_union_non_json_content": {
                "signature": "(client: Anthropic) -> None"
            },
            "test_async_response_parse_expect_model_union_non_json_content": {
                "signature": "async (async_client: AsyncAnthropic) -> None"
            }
        },
        "classes": {}
    },
    "tests\\test_streaming.py": {
        "functions": {
            "test_basic": {
                "signature": "async (sync: bool, client: Anthropic, async_client: AsyncAnthropic) -> None"
            },
            "test_data_missing_event": {
                "signature": "async (sync: bool, client: Anthropic, async_client: AsyncAnthropic) -> None"
            },
            "test_event_missing_data": {
                "signature": "async (sync: bool, client: Anthropic, async_client: AsyncAnthropic) -> None"
            },
            "test_multiple_events": {
                "signature": "async (sync: bool, client: Anthropic, async_client: AsyncAnthropic) -> None"
            },
            "test_multiple_events_with_data": {
                "signature": "async (sync: bool, client: Anthropic, async_client: AsyncAnthropic) -> None"
            },
            "test_multiple_data_lines_with_empty_line": {
                "signature": "async (sync: bool, client: Anthropic, async_client: AsyncAnthropic) -> None"
            },
            "test_data_json_escaped_double_new_line": {
                "signature": "async (sync: bool, client: Anthropic, async_client: AsyncAnthropic) -> None"
            },
            "test_multiple_data_lines": {
                "signature": "async (sync: bool, client: Anthropic, async_client: AsyncAnthropic) -> None"
            },
            "test_special_new_line_character": {
                "signature": "async (sync: bool, client: Anthropic, async_client: AsyncAnthropic) -> None"
            },
            "test_multi_byte_character_multiple_chunks": {
                "signature": "async (sync: bool, client: Anthropic, async_client: AsyncAnthropic) -> None"
            },
            "test_isinstance_check": {
                "signature": "(client: Anthropic, async_client: AsyncAnthropic) -> None"
            },
            "to_aiter": {
                "signature": "async (iter: Iterator[bytes]) -> AsyncIterator[bytes]"
            },
            "iter_next": {
                "signature": "async (iter: Iterator[ServerSentEvent] | AsyncIterator[ServerSentEvent]) -> ServerSentEvent"
            },
            "assert_empty_iter": {
                "signature": "async (iter: Iterator[ServerSentEvent] | AsyncIterator[ServerSentEvent]) -> None"
            },
            "make_event_iterator": {
                "signature": "(content: Iterator[bytes]) -> Iterator[ServerSentEvent] | AsyncIterator[ServerSentEvent]"
            }
        }
    },
    "tests\\test_tokenizer.py": {
        "functions": {
            "before_test": {
                "signature": "() -> None"
            },
            "_sync_tokenizer_test": {
                "signature": "() -> None"
            },
            "test_tokenizers_is_not_imported": {
                "signature": "() -> None"
            },
            "test_threading": {
                "signature": "() -> None"
            },
            "test_concurrent_futures": {
                "signature": "() -> None"
            },
            "test_multiprocessing": {
                "signature": "() -> None"
            },
            "_async_tokenizer_test": {
                "signature": "async () -> None"
            },
            "test_asyncio_tasks": {
                "signature": "async () -> None"
            },
            "test_asyncio_gather": {
                "signature": "async () -> None"
            }
        }
    },
    "tests\\test_transform.py": {
        "functions": {
            "transform": {
                "signature": "async (data: _T, expected_type: object, use_async: bool) -> _T"
            },
            "test_top_level_alias": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_recursive_typeddict": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_list_of_typeddict": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_union_of_typeddict": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_union_of_list": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_includes_unknown_keys": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_ignores_invalid_input": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_iso8601_format": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_optional_iso8601_format": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_required_iso8601_format": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_union_datetime": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_nested_list_iso6801_format": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_datetime_custom_format": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_datetime_with_alias": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_pydantic_model_to_dictionary": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_pydantic_empty_model": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_pydantic_unknown_field": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_pydantic_mismatched_types": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_pydantic_mismatched_object_type": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_pydantic_nested_objects": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_pydantic_default_field": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_iterable_of_dictionaries": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_iterable_union_str": {
                "signature": "async (use_async: bool) -> None"
            },
            "test_base64_file_input": {
                "signature": "async (use_async: bool) -> None"
            }
        },
        "classes": {}
    },
    "tests\\utils.py": {
        "functions": {
            "assert_matches_model": {
                "signature": "(model: type[BaseModelT], value: BaseModelT) -> bool"
            },
            "assert_matches_type": {
                "signature": "(type_: Any, value: object) -> None"
            },
            "_assert_list_type": {
                "signature": "(type_: type[object], value: object) -> None"
            },
            "update_env": {
                "signature": "(**new_env: str | Omit) -> Iterator[None]"
            }
        }
    },
    "tests\\api_resources\\test_client.py": {
        "classes": {
            "TestTopLevel": {
                "methods": {
                    "test_count_tokens": {
                        "signature": "(self, client: Anthropic) -> None"
                    }
                }
            },
            "TestAsyncTopLevel": {
                "methods": {
                    "test_count_tokens": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    }
                }
            }
        }
    },
    "tests\\api_resources\\test_completions.py": {
        "classes": {
            "TestCompletions": {
                "methods": {
                    "test_method_create_overload_1": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_create_with_all_params_overload_1": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_raw_response_create_overload_1": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_streaming_response_create_overload_1": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_create_overload_2": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_create_with_all_params_overload_2": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_raw_response_create_overload_2": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_streaming_response_create_overload_2": {
                        "signature": "(self, client: Anthropic) -> None"
                    }
                }
            },
            "TestAsyncCompletions": {
                "methods": {
                    "test_method_create_overload_1": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_create_with_all_params_overload_1": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_raw_response_create_overload_1": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_streaming_response_create_overload_1": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_create_overload_2": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_create_with_all_params_overload_2": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_raw_response_create_overload_2": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_streaming_response_create_overload_2": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    }
                }
            }
        }
    },
    "tests\\api_resources\\test_messages.py": {
        "classes": {
            "TestMessages": {
                "methods": {
                    "test_method_create_overload_1": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_create_with_all_params_overload_1": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_raw_response_create_overload_1": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_streaming_response_create_overload_1": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_create_overload_2": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_create_with_all_params_overload_2": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_raw_response_create_overload_2": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_streaming_response_create_overload_2": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_deprecated_model_warning": {
                        "signature": "(self, client: Anthropic) -> None"
                    }
                }
            },
            "TestAsyncMessages": {
                "methods": {
                    "test_method_create_overload_1": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_create_with_all_params_overload_1": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_raw_response_create_overload_1": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_streaming_response_create_overload_1": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_create_overload_2": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_create_with_all_params_overload_2": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_raw_response_create_overload_2": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_streaming_response_create_overload_2": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_deprecated_model_warning": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    }
                }
            }
        }
    },
    "tests\\api_resources\\beta\\test_messages.py": {
        "classes": {
            "TestMessages": {
                "methods": {
                    "test_method_create_overload_1": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_create_with_all_params_overload_1": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_raw_response_create_overload_1": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_streaming_response_create_overload_1": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_create_overload_2": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_create_with_all_params_overload_2": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_raw_response_create_overload_2": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_streaming_response_create_overload_2": {
                        "signature": "(self, client: Anthropic) -> None"
                    }
                }
            },
            "TestAsyncMessages": {
                "methods": {
                    "test_method_create_overload_1": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_create_with_all_params_overload_1": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_raw_response_create_overload_1": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_streaming_response_create_overload_1": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_create_overload_2": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_create_with_all_params_overload_2": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_raw_response_create_overload_2": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_streaming_response_create_overload_2": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    }
                }
            }
        }
    },
    "tests\\api_resources\\beta\\messages\\test_batches.py": {
        "classes": {
            "TestBatches": {
                "methods": {
                    "test_method_create": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_create_with_all_params": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_raw_response_create": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_streaming_response_create": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_retrieve": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_retrieve_with_all_params": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_raw_response_retrieve": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_streaming_response_retrieve": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_path_params_retrieve": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_list": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_list_with_all_params": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_raw_response_list": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_streaming_response_list": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_cancel": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_cancel_with_all_params": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_raw_response_cancel": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_streaming_response_cancel": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_path_params_cancel": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_results": {
                        "signature": "(self, client: Anthropic, respx_mock: MockRouter) -> None"
                    },
                    "test_path_params_results": {
                        "signature": "(self, client: Anthropic) -> None"
                    }
                }
            },
            "TestAsyncBatches": {
                "methods": {
                    "test_method_create": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_create_with_all_params": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_raw_response_create": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_streaming_response_create": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_retrieve": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_retrieve_with_all_params": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_raw_response_retrieve": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_streaming_response_retrieve": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_path_params_retrieve": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_list": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_list_with_all_params": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_raw_response_list": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_streaming_response_list": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_cancel": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_cancel_with_all_params": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_raw_response_cancel": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_streaming_response_cancel": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_path_params_cancel": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_results": {
                        "signature": "async (self, async_client: AsyncAnthropic, respx_mock: MockRouter) -> None"
                    },
                    "test_path_params_results": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    }
                }
            }
        }
    },
    "tests\\api_resources\\beta\\prompt_caching\\test_messages.py": {
        "classes": {
            "TestMessages": {
                "methods": {
                    "test_method_create_overload_1": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_create_with_all_params_overload_1": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_raw_response_create_overload_1": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_streaming_response_create_overload_1": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_create_overload_2": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_method_create_with_all_params_overload_2": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_raw_response_create_overload_2": {
                        "signature": "(self, client: Anthropic) -> None"
                    },
                    "test_streaming_response_create_overload_2": {
                        "signature": "(self, client: Anthropic) -> None"
                    }
                }
            },
            "TestAsyncMessages": {
                "methods": {
                    "test_method_create_overload_1": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_create_with_all_params_overload_1": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_raw_response_create_overload_1": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_streaming_response_create_overload_1": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_create_overload_2": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_method_create_with_all_params_overload_2": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_raw_response_create_overload_2": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    },
                    "test_streaming_response_create_overload_2": {
                        "signature": "async (self, async_client: AsyncAnthropic) -> None"
                    }
                }
            }
        }
    },
    "tests\\decoders\\test_jsonl.py": {
        "functions": {
            "test_basic": {
                "signature": "async (sync: bool) -> None"
            },
            "test_new_lines_in_json": {
                "signature": "async (sync: bool) -> None"
            },
            "test_multi_byte_character_multiple_chunks": {
                "signature": "async (sync: bool) -> None"
            },
            "to_aiter": {
                "signature": "async (iter: Iterator[bytes]) -> AsyncIterator[bytes]"
            },
            "iter_next": {
                "signature": "async (iter: Iterator[_T] | AsyncIterator[_T]) -> _T"
            },
            "assert_empty_iter": {
                "signature": "async (decoder: JSONLDecoder[Any] | AsyncJSONLDecoder[Any]) -> None"
            },
            "make_jsonl_iterator": {
                "signature": "(content: Iterator[bytes]) -> JSONLDecoder[_T] | AsyncJSONLDecoder[_T]"
            }
        }
    },
    "tests\\lib\\test_bedrock.py": {
        "functions": {
            "test_messages_retries": {
                "signature": "(respx_mock: MockRouter) -> None"
            },
            "test_messages_retries_async": {
                "signature": "async (respx_mock: MockRouter) -> None"
            }
        },
        "classes": {}
    },
    "tests\\lib\\test_vertex.py": {
        "classes": {
            "TestAnthropicVertex": {
                "methods": {
                    "test_messages_retries": {
                        "signature": "(self, respx_mock: MockRouter) -> None"
                    },
                    "test_copy": {
                        "signature": "(self) -> None"
                    },
                    "test_with_options": {
                        "signature": "(self) -> None"
                    },
                    "test_copy_default_options": {
                        "signature": "(self) -> None"
                    },
                    "test_copy_default_headers": {
                        "signature": "(self) -> None"
                    }
                }
            },
            "TestAsyncAnthropicVertex": {
                "methods": {
                    "test_messages_retries": {
                        "signature": "async (self, respx_mock: MockRouter) -> None"
                    },
                    "test_copy": {
                        "signature": "(self) -> None"
                    },
                    "test_with_options": {
                        "signature": "(self) -> None"
                    },
                    "test_copy_default_options": {
                        "signature": "(self) -> None"
                    },
                    "test_copy_default_headers": {
                        "signature": "(self) -> None"
                    }
                }
            }
        }
    },
    "tests\\lib\\streaming\\test_messages.py": {
        "functions": {
            "basic_response": {
                "signature": "() -> Iterator[bytes]"
            },
            "to_async_iter": {
                "signature": "async (iter: Iterator[_T]) -> AsyncIterator[_T]"
            },
            "assert_basic_response": {
                "signature": "(events: list[MessageStreamEvent], message: Message) -> None"
            },
            "test_stream_method_definition_in_sync": {
                "signature": "(sync: bool) -> None"
            }
        },
        "classes": {
            "TestSyncMessages": {
                "methods": {
                    "test_basic_response": {
                        "signature": "(self, respx_mock: MockRouter) -> None"
                    },
                    "test_context_manager": {
                        "signature": "(self, respx_mock: MockRouter) -> None"
                    },
                    "test_deprecated_model_warning_stream": {
                        "signature": "(self, respx_mock: MockRouter) -> None"
                    }
                }
            },
            "TestAsyncMessages": {
                "methods": {
                    "test_basic_response": {
                        "signature": "async (self, respx_mock: MockRouter) -> None"
                    },
                    "test_context_manager": {
                        "signature": "async (self, respx_mock: MockRouter) -> None"
                    },
                    "test_deprecated_model_warning_stream": {
                        "signature": "async (self, respx_mock: MockRouter) -> None"
                    }
                }
            }
        }
    },
    "tests\\test_utils\\test_proxy.py": {
        "functions": {
            "test_recursive_proxy": {
                "signature": "() -> None"
            }
        },
        "classes": {
            "RecursiveLazyProxy": {
                "methods": {
                    "__load__": {
                        "signature": "(self) -> Any"
                    },
                    "__call__": {
                        "signature": "(self, *_args: Any, **_kwds: Any) -> Any"
                    }
                }
            }
        }
    },
    "tests\\test_utils\\test_typing.py": {
        "functions": {
            "test_extract_type_var": {
                "signature": "() -> None"
            },
            "test_extract_type_var_generic_subclass": {
                "signature": "() -> None"
            },
            "test_extract_type_var_multiple": {
                "signature": "() -> None"
            },
            "test_extract_type_var_generic_subclass_multiple": {
                "signature": "() -> None"
            },
            "test_extract_type_var_generic_subclass_different_ordering_multiple": {
                "signature": "() -> None"
            }
        },
        "classes": {}
    }
}